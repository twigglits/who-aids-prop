# Some variables. Note that if set, environment variables will have
# Precedence.
$SIMPACT_OUTPUT_PREFIX = model_1_seed_1
$SIMPACT_DATA_DIR = /home/jupyter/who-aids-prop/build/data/

# The configuration file format is quite straightforward, it is just a set of
# 'key = value' lines. Lines that start with '#' are treated as comments and
# are ignored.
#
# If the key starts with a dollar ('$') sign, the rest of the key is 
# considered to be the name of a variable, which may be used later on in the
# file. To use such a variable in a specified value, you need to surround
# the variable name with '${' and '}'. For example, one could write:
#
#     $PREFIX = MyCustomPrefix
#     logsystem.outfile.logevents = ${PREFIX}-output.log
#
# and the file used will have the name 'MyCustomPrefix-output.log'.
#
# In the same way, environment variables can be used, and, in fact, 
# environment variables will take precedence over these internal variables.
# This way, it is easy to change the content of these variables on the command
# line
#
# Note that no calculations can be performed in this file anymore, so instead
# of writing 1.0/2.0, you'd need to write 0.5 for example.

# The following depends on birth.pregnancyduration.dist.type = beta
# birth.pregnancyduration.dist.beta.a
# birth.pregnancyduration.dist.beta.b
# birth.pregnancyduration.dist.beta.min
# birth.pregnancyduration.dist.beta.max
#
# The following depends on birth.pregnancyduration.dist.type = discrete.csv.onecol
# birth.pregnancyduration.dist.discrete.csv.onecol.file
# birth.pregnancyduration.dist.discrete.csv.onecol.xmin
# birth.pregnancyduration.dist.discrete.csv.onecol.xmax
# birth.pregnancyduration.dist.discrete.csv.onecol.ycolumn
# birth.pregnancyduration.dist.discrete.csv.onecol.floor
#
# The following depends on birth.pregnancyduration.dist.type = discrete.csv.twocol
# birth.pregnancyduration.dist.discrete.csv.twocol.file
# birth.pregnancyduration.dist.discrete.csv.twocol.xcolumn
# birth.pregnancyduration.dist.discrete.csv.twocol.ycolumn
# birth.pregnancyduration.dist.discrete.csv.twocol.floor
#
# The following depends on birth.pregnancyduration.dist.type = discrete.inline
# birth.pregnancyduration.dist.discrete.inline.xvalues
# birth.pregnancyduration.dist.discrete.inline.yvalues
# birth.pregnancyduration.dist.discrete.inline.floor
#
# The following depends on birth.pregnancyduration.dist.type = exponential
# birth.pregnancyduration.dist.exponential.lambda
#
# The following depends on birth.pregnancyduration.dist.type = gamma
# birth.pregnancyduration.dist.gamma.a
# birth.pregnancyduration.dist.gamma.b
#
# The following depends on birth.pregnancyduration.dist.type = lognormal
# birth.pregnancyduration.dist.lognormal.zeta
# birth.pregnancyduration.dist.lognormal.sigma
#
# The following depends on birth.pregnancyduration.dist.type = normal
# birth.pregnancyduration.dist.normal.mu
# birth.pregnancyduration.dist.normal.sigma
# birth.pregnancyduration.dist.normal.min
# birth.pregnancyduration.dist.normal.max
#
# The following depends on birth.pregnancyduration.dist.type = uniform
# birth.pregnancyduration.dist.uniform.min
# birth.pregnancyduration.dist.uniform.max
#
# The following depends on conception.wsf.dist.type = beta
# conception.wsf.dist.beta.a
# conception.wsf.dist.beta.b
# conception.wsf.dist.beta.min
# conception.wsf.dist.beta.max
#
# The following depends on conception.wsf.dist.type = discrete.csv.onecol
# conception.wsf.dist.discrete.csv.onecol.file
# conception.wsf.dist.discrete.csv.onecol.xmin
# conception.wsf.dist.discrete.csv.onecol.xmax
# conception.wsf.dist.discrete.csv.onecol.ycolumn
# conception.wsf.dist.discrete.csv.onecol.floor
#
# The following depends on conception.wsf.dist.type = discrete.csv.twocol
# conception.wsf.dist.discrete.csv.twocol.file
# conception.wsf.dist.discrete.csv.twocol.xcolumn
# conception.wsf.dist.discrete.csv.twocol.ycolumn
# conception.wsf.dist.discrete.csv.twocol.floor
#
# The following depends on conception.wsf.dist.type = discrete.inline
# conception.wsf.dist.discrete.inline.xvalues
# conception.wsf.dist.discrete.inline.yvalues
# conception.wsf.dist.discrete.inline.floor
#
# The following depends on conception.wsf.dist.type = exponential
# conception.wsf.dist.exponential.lambda
#
# The following depends on conception.wsf.dist.type = gamma
# conception.wsf.dist.gamma.a
# conception.wsf.dist.gamma.b
#
# The following depends on conception.wsf.dist.type = lognormal
# conception.wsf.dist.lognormal.zeta
# conception.wsf.dist.lognormal.sigma
#
# The following depends on conception.wsf.dist.type = normal
# conception.wsf.dist.normal.mu
# conception.wsf.dist.normal.sigma
# conception.wsf.dist.normal.min
# conception.wsf.dist.normal.max
#
# The following depends on conception.wsf.dist.type = uniform
# conception.wsf.dist.uniform.min
# conception.wsf.dist.uniform.max
#
# The following depends on EventCondom.m_condomprobDist.dist.type = beta
# EventCondom.m_condomprobDist.dist.beta.a
# EventCondom.m_condomprobDist.dist.beta.b
# EventCondom.m_condomprobDist.dist.beta.min
# EventCondom.m_condomprobDist.dist.beta.max
#
# The following depends on EventCondom.m_condomprobDist.dist.type = discrete.csv.onecol
# EventCondom.m_condomprobDist.dist.discrete.csv.onecol.file
# EventCondom.m_condomprobDist.dist.discrete.csv.onecol.xmin
# EventCondom.m_condomprobDist.dist.discrete.csv.onecol.xmax
# EventCondom.m_condomprobDist.dist.discrete.csv.onecol.ycolumn
# EventCondom.m_condomprobDist.dist.discrete.csv.onecol.floor
#
# The following depends on EventCondom.m_condomprobDist.dist.type = discrete.csv.twocol
# EventCondom.m_condomprobDist.dist.discrete.csv.twocol.file
# EventCondom.m_condomprobDist.dist.discrete.csv.twocol.xcolumn
# EventCondom.m_condomprobDist.dist.discrete.csv.twocol.ycolumn
# EventCondom.m_condomprobDist.dist.discrete.csv.twocol.floor
#
# The following depends on EventCondom.m_condomprobDist.dist.type = discrete.inline
# EventCondom.m_condomprobDist.dist.discrete.inline.xvalues
# EventCondom.m_condomprobDist.dist.discrete.inline.yvalues
# EventCondom.m_condomprobDist.dist.discrete.inline.floor
#
# The following depends on EventCondom.m_condomprobDist.dist.type = exponential
# EventCondom.m_condomprobDist.dist.exponential.lambda
#
# The following depends on EventCondom.m_condomprobDist.dist.type = fixed
# EventCondom.m_condomprobDist.dist.fixed.value
#
# The following depends on EventCondom.m_condomprobDist.dist.type = gamma
# EventCondom.m_condomprobDist.dist.gamma.a
# EventCondom.m_condomprobDist.dist.gamma.b
#
# The following depends on EventCondom.m_condomprobDist.dist.type = lognormal
# EventCondom.m_condomprobDist.dist.lognormal.zeta
# EventCondom.m_condomprobDist.dist.lognormal.sigma
#
# The following depends on EventCondom.m_condomprobDist.dist.type = normal
# EventCondom.m_condomprobDist.dist.normal.mu
# EventCondom.m_condomprobDist.dist.normal.sigma
# EventCondom.m_condomprobDist.dist.normal.min
# EventCondom.m_condomprobDist.dist.normal.max
#
# The following depends on EventCondom.m_condomscheduleDist.dist.type = beta
# EventCondom.m_condomscheduleDist.dist.beta.a
# EventCondom.m_condomscheduleDist.dist.beta.b
# EventCondom.m_condomscheduleDist.dist.beta.min
# EventCondom.m_condomscheduleDist.dist.beta.max
#
# The following depends on EventCondom.m_condomscheduleDist.dist.type = discrete.csv.onecol
# EventCondom.m_condomscheduleDist.dist.discrete.csv.onecol.file
# EventCondom.m_condomscheduleDist.dist.discrete.csv.onecol.xmin
# EventCondom.m_condomscheduleDist.dist.discrete.csv.onecol.xmax
# EventCondom.m_condomscheduleDist.dist.discrete.csv.onecol.ycolumn
# EventCondom.m_condomscheduleDist.dist.discrete.csv.onecol.floor
#
# The following depends on EventCondom.m_condomscheduleDist.dist.type = discrete.csv.twocol
# EventCondom.m_condomscheduleDist.dist.discrete.csv.twocol.file
# EventCondom.m_condomscheduleDist.dist.discrete.csv.twocol.xcolumn
# EventCondom.m_condomscheduleDist.dist.discrete.csv.twocol.ycolumn
# EventCondom.m_condomscheduleDist.dist.discrete.csv.twocol.floor
#
# The following depends on EventCondom.m_condomscheduleDist.dist.type = discrete.inline
# EventCondom.m_condomscheduleDist.dist.discrete.inline.xvalues
# EventCondom.m_condomscheduleDist.dist.discrete.inline.yvalues
# EventCondom.m_condomscheduleDist.dist.discrete.inline.floor
#
# The following depends on EventCondom.m_condomscheduleDist.dist.type = exponential
# EventCondom.m_condomscheduleDist.dist.exponential.lambda
#
# The following depends on EventCondom.m_condomscheduleDist.dist.type = fixed
# EventCondom.m_condomscheduleDist.dist.fixed.value
#
# The following depends on EventCondom.m_condomscheduleDist.dist.type = gamma
# EventCondom.m_condomscheduleDist.dist.gamma.a
# EventCondom.m_condomscheduleDist.dist.gamma.b
#
# The following depends on EventCondom.m_condomscheduleDist.dist.type = lognormal
# EventCondom.m_condomscheduleDist.dist.lognormal.zeta
# EventCondom.m_condomscheduleDist.dist.lognormal.sigma
#
# The following depends on EventCondom.m_condomscheduleDist.dist.type = normal
# EventCondom.m_condomscheduleDist.dist.normal.mu
# EventCondom.m_condomscheduleDist.dist.normal.sigma
# EventCondom.m_condomscheduleDist.dist.normal.min
# EventCondom.m_condomscheduleDist.dist.normal.max
#
# The following depends on EventDVRDROP.m_DVRDROPprobDist.dist.type = beta
# EventDVRDROP.m_DVRDROPprobDist.dist.beta.a
# EventDVRDROP.m_DVRDROPprobDist.dist.beta.b
# EventDVRDROP.m_DVRDROPprobDist.dist.beta.min
# EventDVRDROP.m_DVRDROPprobDist.dist.beta.max
#
# The following depends on EventDVRDROP.m_DVRDROPprobDist.dist.type = discrete.csv.onecol
# EventDVRDROP.m_DVRDROPprobDist.dist.discrete.csv.onecol.file
# EventDVRDROP.m_DVRDROPprobDist.dist.discrete.csv.onecol.xmin
# EventDVRDROP.m_DVRDROPprobDist.dist.discrete.csv.onecol.xmax
# EventDVRDROP.m_DVRDROPprobDist.dist.discrete.csv.onecol.ycolumn
# EventDVRDROP.m_DVRDROPprobDist.dist.discrete.csv.onecol.floor
#
# The following depends on EventDVRDROP.m_DVRDROPprobDist.dist.type = discrete.csv.twocol
# EventDVRDROP.m_DVRDROPprobDist.dist.discrete.csv.twocol.file
# EventDVRDROP.m_DVRDROPprobDist.dist.discrete.csv.twocol.xcolumn
# EventDVRDROP.m_DVRDROPprobDist.dist.discrete.csv.twocol.ycolumn
# EventDVRDROP.m_DVRDROPprobDist.dist.discrete.csv.twocol.floor
#
# The following depends on EventDVRDROP.m_DVRDROPprobDist.dist.type = discrete.inline
# EventDVRDROP.m_DVRDROPprobDist.dist.discrete.inline.xvalues
# EventDVRDROP.m_DVRDROPprobDist.dist.discrete.inline.yvalues
# EventDVRDROP.m_DVRDROPprobDist.dist.discrete.inline.floor
#
# The following depends on EventDVRDROP.m_DVRDROPprobDist.dist.type = exponential
# EventDVRDROP.m_DVRDROPprobDist.dist.exponential.lambda
#
# The following depends on EventDVRDROP.m_DVRDROPprobDist.dist.type = fixed
# EventDVRDROP.m_DVRDROPprobDist.dist.fixed.value
#
# The following depends on EventDVRDROP.m_DVRDROPprobDist.dist.type = gamma
# EventDVRDROP.m_DVRDROPprobDist.dist.gamma.a
# EventDVRDROP.m_DVRDROPprobDist.dist.gamma.b
#
# The following depends on EventDVRDROP.m_DVRDROPprobDist.dist.type = lognormal
# EventDVRDROP.m_DVRDROPprobDist.dist.lognormal.zeta
# EventDVRDROP.m_DVRDROPprobDist.dist.lognormal.sigma
#
# The following depends on EventDVRDROP.m_DVRDROPprobDist.dist.type = normal
# EventDVRDROP.m_DVRDROPprobDist.dist.normal.mu
# EventDVRDROP.m_DVRDROPprobDist.dist.normal.sigma
# EventDVRDROP.m_DVRDROPprobDist.dist.normal.min
# EventDVRDROP.m_DVRDROPprobDist.dist.normal.max
#
# The following depends on dropout.interval.dist.type = beta
# dropout.interval.dist.beta.a
# dropout.interval.dist.beta.b
# dropout.interval.dist.beta.min
# dropout.interval.dist.beta.max
#
# The following depends on dropout.interval.dist.type = discrete.csv.onecol
# dropout.interval.dist.discrete.csv.onecol.file
# dropout.interval.dist.discrete.csv.onecol.xmin
# dropout.interval.dist.discrete.csv.onecol.xmax
# dropout.interval.dist.discrete.csv.onecol.ycolumn
# dropout.interval.dist.discrete.csv.onecol.floor
#
# The following depends on dropout.interval.dist.type = discrete.csv.twocol
# dropout.interval.dist.discrete.csv.twocol.file
# dropout.interval.dist.discrete.csv.twocol.xcolumn
# dropout.interval.dist.discrete.csv.twocol.ycolumn
# dropout.interval.dist.discrete.csv.twocol.floor
#
# The following depends on dropout.interval.dist.type = discrete.inline
# dropout.interval.dist.discrete.inline.xvalues
# dropout.interval.dist.discrete.inline.yvalues
# dropout.interval.dist.discrete.inline.floor
#
# The following depends on dropout.interval.dist.type = exponential
# dropout.interval.dist.exponential.lambda
#
# The following depends on dropout.interval.dist.type = gamma
# dropout.interval.dist.gamma.a
# dropout.interval.dist.gamma.b
#
# The following depends on dropout.interval.dist.type = lognormal
# dropout.interval.dist.lognormal.zeta
# dropout.interval.dist.lognormal.sigma
#
# The following depends on dropout.interval.dist.type = normal
# dropout.interval.dist.normal.mu
# dropout.interval.dist.normal.sigma
# dropout.interval.dist.normal.min
# dropout.interval.dist.normal.max
#
# The following depends on dropout.interval.dist.type = uniform
# dropout.interval.dist.uniform.min
# dropout.interval.dist.uniform.max
#
# The following depends on formationmsm.hazard.type = agegap
# formationmsm.hazard.agegap.baseline
# formationmsm.hazard.agegap.numrel_sum
# formationmsm.hazard.agegap.numrel_diff
# formationmsm.hazard.agegap.meanage
# formationmsm.hazard.agegap.eagerness_sum
# formationmsm.hazard.agegap.eagerness_diff
# formationmsm.hazard.agegap.gap_factor
# formationmsm.hazard.agegap.gap_agescale
# formationmsm.hazard.agegap.distance
# formationmsm.hazard.agegap.beta
# formationmsm.hazard.agegap.t_max
#
# The following depends on formationmsm.hazard.type = agegapry
# formationmsm.hazard.agegapry.baseline
# formationmsm.hazard.agegapry.numrel_sum
# formationmsm.hazard.agegapry.numrel_scale
# formationmsm.hazard.agegapry.numrel_diff
# formationmsm.hazard.agegapry.meanage
# formationmsm.hazard.agegapry.eagerness_sum
# formationmsm.hazard.agegapry.eagerness_diff
# formationmsm.hazard.agegapry.gap_factor_const
# formationmsm.hazard.agegapry.gap_factor_exp
# formationmsm.hazard.agegapry.gap_factor_age
# formationmsm.hazard.agegapry.gap_agescale
# formationmsm.hazard.agegapry.distance
# formationmsm.hazard.agegapry.beta
# formationmsm.hazard.agegapry.t_max
# formationmsm.hazard.agegapry.maxageref.diff
#
# The following depends on formation.hazard.type = agegap
# formation.hazard.agegap.baseline
# formation.hazard.agegap.numrel_man
# formation.hazard.agegap.numrel_woman
# formation.hazard.agegap.numrel_diff
# formation.hazard.agegap.meanage
# formation.hazard.agegap.eagerness_sum
# formation.hazard.agegap.eagerness_diff
# formation.hazard.agegap.gap_factor_man
# formation.hazard.agegap.gap_agescale_man
# formation.hazard.agegap.gap_factor_woman
# formation.hazard.agegap.gap_agescale_woman
# formation.hazard.agegap.distance
# formation.hazard.agegap.beta
# formation.hazard.agegap.t_max
#
# The following depends on formation.hazard.type = simple
# formation.hazard.simple.alpha_0
# formation.hazard.simple.alpha_1
# formation.hazard.simple.alpha_2
# formation.hazard.simple.alpha_3
# formation.hazard.simple.alpha_4
# formation.hazard.simple.alpha_5
# formation.hazard.simple.alpha_6
# formation.hazard.simple.alpha_7
# formation.hazard.simple.alpha_dist
# formation.hazard.simple.Dp
# formation.hazard.simple.beta
# formation.hazard.simple.t_max
#
# The following depends on hivseed.type = fraction
# hivseed.fraction
#
# The following depends on hivtransmission.m_condomformationdist.dist.type = beta
# hivtransmission.m_condomformationdist.dist.beta.a
# hivtransmission.m_condomformationdist.dist.beta.b
# hivtransmission.m_condomformationdist.dist.beta.min
# hivtransmission.m_condomformationdist.dist.beta.max
#
# The following depends on hivtransmission.m_condomformationdist.dist.type = discrete.csv.onecol
# hivtransmission.m_condomformationdist.dist.discrete.csv.onecol.file
# hivtransmission.m_condomformationdist.dist.discrete.csv.onecol.xmin
# hivtransmission.m_condomformationdist.dist.discrete.csv.onecol.xmax
# hivtransmission.m_condomformationdist.dist.discrete.csv.onecol.ycolumn
# hivtransmission.m_condomformationdist.dist.discrete.csv.onecol.floor
#
# The following depends on hivtransmission.m_condomformationdist.dist.type = discrete.inline
# hivtransmission.m_condomformationdist.dist.discrete.inline.xvalues
# hivtransmission.m_condomformationdist.dist.discrete.inline.yvalues
# hivtransmission.m_condomformationdist.dist.discrete.inline.floor
#
# The following depends on hivtransmission.m_condomformationdist.dist.type = exponential
# hivtransmission.m_condomformationdist.dist.exponential.lambda
#
# The following depends on hivtransmission.m_condomformationdist.dist.type = fixed
# hivtransmission.m_condomformationdist.dist.fixed.value
#
# The following depends on hivtransmission.m_condomformationdist.dist.type = gamma
# hivtransmission.m_condomformationdist.dist.gamma.a
# hivtransmission.m_condomformationdist.dist.gamma.b
#
# The following depends on hivtransmission.m_condomformationdist.dist.type = lognormal
# hivtransmission.m_condomformationdist.dist.lognormal.zeta
# hivtransmission.m_condomformationdist.dist.lognormal.sigma
#
# The following depends on hivtransmission.m_condomformationdist.dist.type = normal
# hivtransmission.m_condomformationdist.dist.normal.mu
# hivtransmission.m_condomformationdist.dist.normal.sigma
# hivtransmission.m_condomformationdist.dist.normal.min
# hivtransmission.m_condomformationdist.dist.normal.max
#
# The following depends on hivtransmission.m_condomformationdist.dist.type = uniform
# hivtransmission.m_condomformationdist.dist.uniform.min
# hivtransmission.m_condomformationdist.dist.uniform.max
#
# The following depends on hsv2seed.type = amount
# hsv2seed.amount
# hsv2seed.stop.short
#
# The following depends on monitoring.m_artDist.dist.type = beta
# monitoring.m_artDist.dist.beta.a
# monitoring.m_artDist.dist.beta.b
# monitoring.m_artDist.dist.beta.min
# monitoring.m_artDist.dist.beta.max
#
# The following depends on monitoring.m_artDist.dist.type = discrete.csv.onecol
# monitoring.m_artDist.dist.discrete.csv.onecol.file
# monitoring.m_artDist.dist.discrete.csv.onecol.xmin
# monitoring.m_artDist.dist.discrete.csv.onecol.xmax
# monitoring.m_artDist.dist.discrete.csv.onecol.ycolumn
# monitoring.m_artDist.dist.discrete.csv.onecol.floor
#
# The following depends on monitoring.m_artDist.dist.type = discrete.csv.twocol
# monitoring.m_artDist.dist.discrete.csv.twocol.file
# monitoring.m_artDist.dist.discrete.csv.twocol.xcolumn
# monitoring.m_artDist.dist.discrete.csv.twocol.ycolumn
# monitoring.m_artDist.dist.discrete.csv.twocol.floor
#
# The following depends on monitoring.m_artDist.dist.type = discrete.inline
# monitoring.m_artDist.dist.discrete.inline.xvalues
# monitoring.m_artDist.dist.discrete.inline.yvalues
# monitoring.m_artDist.dist.discrete.inline.floor
#
# The following depends on monitoring.m_artDist.dist.type = exponential
# monitoring.m_artDist.dist.exponential.lambda
#
# The following depends on monitoring.m_artDist.dist.type = fixed
# monitoring.m_artDist.dist.fixed.value
#
# The following depends on monitoring.m_artDist.dist.type = gamma
# monitoring.m_artDist.dist.gamma.a
# monitoring.m_artDist.dist.gamma.b
#
# The following depends on monitoring.m_artDist.dist.type = lognormal
# monitoring.m_artDist.dist.lognormal.zeta
# monitoring.m_artDist.dist.lognormal.sigma
#
# The following depends on monitoring.m_artDist.dist.type = uniform
# monitoring.m_artDist.dist.uniform.min
# monitoring.m_artDist.dist.uniform.max
#
# The following depends on mortality.aids.survtime.art_e.dist.type = beta
# mortality.aids.survtime.art_e.dist.beta.a
# mortality.aids.survtime.art_e.dist.beta.b
# mortality.aids.survtime.art_e.dist.beta.min
# mortality.aids.survtime.art_e.dist.beta.max
#
# The following depends on mortality.aids.survtime.art_e.dist.type = discrete.csv.onecol
# mortality.aids.survtime.art_e.dist.discrete.csv.onecol.file
# mortality.aids.survtime.art_e.dist.discrete.csv.onecol.xmin
# mortality.aids.survtime.art_e.dist.discrete.csv.onecol.xmax
# mortality.aids.survtime.art_e.dist.discrete.csv.onecol.ycolumn
# mortality.aids.survtime.art_e.dist.discrete.csv.onecol.floor
#
# The following depends on mortality.aids.survtime.art_e.dist.type = discrete.csv.twocol
# mortality.aids.survtime.art_e.dist.discrete.csv.twocol.file
# mortality.aids.survtime.art_e.dist.discrete.csv.twocol.xcolumn
# mortality.aids.survtime.art_e.dist.discrete.csv.twocol.ycolumn
# mortality.aids.survtime.art_e.dist.discrete.csv.twocol.floor
#
# The following depends on mortality.aids.survtime.art_e.dist.type = discrete.inline
# mortality.aids.survtime.art_e.dist.discrete.inline.xvalues
# mortality.aids.survtime.art_e.dist.discrete.inline.yvalues
# mortality.aids.survtime.art_e.dist.discrete.inline.floor
#
# The following depends on mortality.aids.survtime.art_e.dist.type = exponential
# mortality.aids.survtime.art_e.dist.exponential.lambda
#
# The following depends on mortality.aids.survtime.art_e.dist.type = fixed
# mortality.aids.survtime.art_e.dist.fixed.value
#
# The following depends on mortality.aids.survtime.art_e.dist.type = gamma
# mortality.aids.survtime.art_e.dist.gamma.a
# mortality.aids.survtime.art_e.dist.gamma.b
#
# The following depends on mortality.aids.survtime.art_e.dist.type = lognormal
# mortality.aids.survtime.art_e.dist.lognormal.zeta
# mortality.aids.survtime.art_e.dist.lognormal.sigma
#
# The following depends on mortality.aids.survtime.art_e.dist.type = normal
# mortality.aids.survtime.art_e.dist.normal.mu
# mortality.aids.survtime.art_e.dist.normal.sigma
# mortality.aids.survtime.art_e.dist.normal.min
# mortality.aids.survtime.art_e.dist.normal.max
#
# The following depends on EventPrepDrop.interval.dist.type = beta
# EventPrepDrop.interval.dist.beta.a
# EventPrepDrop.interval.dist.beta.b
# EventPrepDrop.interval.dist.beta.min
# EventPrepDrop.interval.dist.beta.max
#
# The following depends on EventPrepDrop.interval.dist.type = discrete.csv.onecol
# EventPrepDrop.interval.dist.discrete.csv.onecol.file
# EventPrepDrop.interval.dist.discrete.csv.onecol.xmin
# EventPrepDrop.interval.dist.discrete.csv.onecol.xmax
# EventPrepDrop.interval.dist.discrete.csv.onecol.ycolumn
# EventPrepDrop.interval.dist.discrete.csv.onecol.floor
#
# The following depends on EventPrepDrop.interval.dist.type = discrete.csv.twocol
# EventPrepDrop.interval.dist.discrete.csv.twocol.file
# EventPrepDrop.interval.dist.discrete.csv.twocol.xcolumn
# EventPrepDrop.interval.dist.discrete.csv.twocol.ycolumn
# EventPrepDrop.interval.dist.discrete.csv.twocol.floor
#
# The following depends on EventPrepDrop.interval.dist.type = discrete.inline
# EventPrepDrop.interval.dist.discrete.inline.xvalues
# EventPrepDrop.interval.dist.discrete.inline.yvalues
# EventPrepDrop.interval.dist.discrete.inline.floor
#
# The following depends on EventPrepDrop.interval.dist.type = exponential
# EventPrepDrop.interval.dist.exponential.lambda
#
# The following depends on EventPrepDrop.interval.dist.type = fixed
# EventPrepDrop.interval.dist.fixed.value
#
# The following depends on EventPrepDrop.interval.dist.type = gamma
# EventPrepDrop.interval.dist.gamma.a
# EventPrepDrop.interval.dist.gamma.b
#
# The following depends on EventPrepDrop.interval.dist.type = lognormal
# EventPrepDrop.interval.dist.lognormal.zeta
# EventPrepDrop.interval.dist.lognormal.sigma
#
# The following depends on EventPrepDrop.interval.dist.type = normal
# EventPrepDrop.interval.dist.normal.mu
# EventPrepDrop.interval.dist.normal.sigma
# EventPrepDrop.interval.dist.normal.min
# EventPrepDrop.interval.dist.normal.max
#
# The following depends on EventPrep.m_prepprobDist.dist.type = beta
# EventPrep.m_prepprobDist.dist.beta.a
# EventPrep.m_prepprobDist.dist.beta.b
# EventPrep.m_prepprobDist.dist.beta.min
# EventPrep.m_prepprobDist.dist.beta.max
#
# The following depends on EventPrep.m_prepprobDist.dist.type = discrete.csv.onecol
# EventPrep.m_prepprobDist.dist.discrete.csv.onecol.file
# EventPrep.m_prepprobDist.dist.discrete.csv.onecol.xmin
# EventPrep.m_prepprobDist.dist.discrete.csv.onecol.xmax
# EventPrep.m_prepprobDist.dist.discrete.csv.onecol.ycolumn
# EventPrep.m_prepprobDist.dist.discrete.csv.onecol.floor
#
# The following depends on EventPrep.m_prepprobDist.dist.type = discrete.csv.twocol
# EventPrep.m_prepprobDist.dist.discrete.csv.twocol.file
# EventPrep.m_prepprobDist.dist.discrete.csv.twocol.xcolumn
# EventPrep.m_prepprobDist.dist.discrete.csv.twocol.ycolumn
# EventPrep.m_prepprobDist.dist.discrete.csv.twocol.floor
#
# The following depends on EventPrep.m_prepprobDist.dist.type = discrete.inline
# EventPrep.m_prepprobDist.dist.discrete.inline.xvalues
# EventPrep.m_prepprobDist.dist.discrete.inline.yvalues
# EventPrep.m_prepprobDist.dist.discrete.inline.floor
#
# The following depends on EventPrep.m_prepprobDist.dist.type = exponential
# EventPrep.m_prepprobDist.dist.exponential.lambda
#
# The following depends on EventPrep.m_prepprobDist.dist.type = fixed
# EventPrep.m_prepprobDist.dist.fixed.value
#
# The following depends on EventPrep.m_prepprobDist.dist.type = gamma
# EventPrep.m_prepprobDist.dist.gamma.a
# EventPrep.m_prepprobDist.dist.gamma.b
#
# The following depends on EventPrep.m_prepprobDist.dist.type = lognormal
# EventPrep.m_prepprobDist.dist.lognormal.zeta
# EventPrep.m_prepprobDist.dist.lognormal.sigma
#
# The following depends on EventPrep.m_prepprobDist.dist.type = normal
# EventPrep.m_prepprobDist.dist.normal.mu
# EventPrep.m_prepprobDist.dist.normal.sigma
# EventPrep.m_prepprobDist.dist.normal.min
# EventPrep.m_prepprobDist.dist.normal.max
#
# The following depends on EventPrep.m_prepscheduleDist.dist.type = beta
# EventPrep.m_prepscheduleDist.dist.beta.a
# EventPrep.m_prepscheduleDist.dist.beta.b
# EventPrep.m_prepscheduleDist.dist.beta.min
# EventPrep.m_prepscheduleDist.dist.beta.max
#
# The following depends on EventPrep.m_prepscheduleDist.dist.type = discrete.csv.onecol
# EventPrep.m_prepscheduleDist.dist.discrete.csv.onecol.file
# EventPrep.m_prepscheduleDist.dist.discrete.csv.onecol.xmin
# EventPrep.m_prepscheduleDist.dist.discrete.csv.onecol.xmax
# EventPrep.m_prepscheduleDist.dist.discrete.csv.onecol.ycolumn
# EventPrep.m_prepscheduleDist.dist.discrete.csv.onecol.floor
#
# The following depends on EventPrep.m_prepscheduleDist.dist.type = discrete.csv.twocol
# EventPrep.m_prepscheduleDist.dist.discrete.csv.twocol.file
# EventPrep.m_prepscheduleDist.dist.discrete.csv.twocol.xcolumn
# EventPrep.m_prepscheduleDist.dist.discrete.csv.twocol.ycolumn
# EventPrep.m_prepscheduleDist.dist.discrete.csv.twocol.floor
#
# The following depends on EventPrep.m_prepscheduleDist.dist.type = discrete.inline
# EventPrep.m_prepscheduleDist.dist.discrete.inline.xvalues
# EventPrep.m_prepscheduleDist.dist.discrete.inline.yvalues
# EventPrep.m_prepscheduleDist.dist.discrete.inline.floor
#
# The following depends on EventPrep.m_prepscheduleDist.dist.type = exponential
# EventPrep.m_prepscheduleDist.dist.exponential.lambda
#
# The following depends on EventPrep.m_prepscheduleDist.dist.type = gamma
# EventPrep.m_prepscheduleDist.dist.gamma.a
# EventPrep.m_prepscheduleDist.dist.gamma.b
#
# The following depends on EventPrep.m_prepscheduleDist.dist.type = lognormal
# EventPrep.m_prepscheduleDist.dist.lognormal.zeta
# EventPrep.m_prepscheduleDist.dist.lognormal.sigma
#
# The following depends on EventPrep.m_prepscheduleDist.dist.type = normal
# EventPrep.m_prepscheduleDist.dist.normal.mu
# EventPrep.m_prepscheduleDist.dist.normal.sigma
# EventPrep.m_prepscheduleDist.dist.normal.min
# EventPrep.m_prepscheduleDist.dist.normal.max
#
# The following depends on EventPrep.m_prepscheduleDist.dist.type = uniform
# EventPrep.m_prepscheduleDist.dist.uniform.min
# EventPrep.m_prepscheduleDist.dist.uniform.max
#
# The following depends on relocation.enabled = yes
# relocation.hazard.a
# relocation.hazard.b
# relocation.hazard.t_max
#
# The following depends on EventVMMC.m_vmmcprobDist.dist.type = beta
# EventVMMC.m_vmmcprobDist.dist.beta.a
# EventVMMC.m_vmmcprobDist.dist.beta.b
# EventVMMC.m_vmmcprobDist.dist.beta.min
# EventVMMC.m_vmmcprobDist.dist.beta.max
#
# The following depends on EventVMMC.m_vmmcprobDist.dist.type = discrete.csv.onecol
# EventVMMC.m_vmmcprobDist.dist.discrete.csv.onecol.file
# EventVMMC.m_vmmcprobDist.dist.discrete.csv.onecol.xmin
# EventVMMC.m_vmmcprobDist.dist.discrete.csv.onecol.xmax
# EventVMMC.m_vmmcprobDist.dist.discrete.csv.onecol.ycolumn
# EventVMMC.m_vmmcprobDist.dist.discrete.csv.onecol.floor
#
# The following depends on EventVMMC.m_vmmcprobDist.dist.type = discrete.csv.twocol
# EventVMMC.m_vmmcprobDist.dist.discrete.csv.twocol.file
# EventVMMC.m_vmmcprobDist.dist.discrete.csv.twocol.xcolumn
# EventVMMC.m_vmmcprobDist.dist.discrete.csv.twocol.ycolumn
# EventVMMC.m_vmmcprobDist.dist.discrete.csv.twocol.floor
#
# The following depends on EventVMMC.m_vmmcprobDist.dist.type = discrete.inline
# EventVMMC.m_vmmcprobDist.dist.discrete.inline.xvalues
# EventVMMC.m_vmmcprobDist.dist.discrete.inline.yvalues
# EventVMMC.m_vmmcprobDist.dist.discrete.inline.floor
#
# The following depends on EventVMMC.m_vmmcprobDist.dist.type = exponential
# EventVMMC.m_vmmcprobDist.dist.exponential.lambda
#
# The following depends on EventVMMC.m_vmmcprobDist.dist.type = fixed
# EventVMMC.m_vmmcprobDist.dist.fixed.value
#
# The following depends on EventVMMC.m_vmmcprobDist.dist.type = gamma
# EventVMMC.m_vmmcprobDist.dist.gamma.a
# EventVMMC.m_vmmcprobDist.dist.gamma.b
#
# The following depends on EventVMMC.m_vmmcprobDist.dist.type = lognormal
# EventVMMC.m_vmmcprobDist.dist.lognormal.zeta
# EventVMMC.m_vmmcprobDist.dist.lognormal.sigma
#
# The following depends on EventVMMC.m_vmmcprobDist.dist.type = normal
# EventVMMC.m_vmmcprobDist.dist.normal.mu
# EventVMMC.m_vmmcprobDist.dist.normal.sigma
# EventVMMC.m_vmmcprobDist.dist.normal.min
# EventVMMC.m_vmmcprobDist.dist.normal.max
#
# The following depends on EventVMMC.m_vmmcscheduleDist.dist.type = beta
# EventVMMC.m_vmmcscheduleDist.dist.beta.a
# EventVMMC.m_vmmcscheduleDist.dist.beta.b
# EventVMMC.m_vmmcscheduleDist.dist.beta.min
# EventVMMC.m_vmmcscheduleDist.dist.beta.max
#
# The following depends on EventVMMC.m_vmmcscheduleDist.dist.type = discrete.csv.onecol
# EventVMMC.m_vmmcscheduleDist.dist.discrete.csv.onecol.file
# EventVMMC.m_vmmcscheduleDist.dist.discrete.csv.onecol.xmin
# EventVMMC.m_vmmcscheduleDist.dist.discrete.csv.onecol.xmax
# EventVMMC.m_vmmcscheduleDist.dist.discrete.csv.onecol.ycolumn
# EventVMMC.m_vmmcscheduleDist.dist.discrete.csv.onecol.floor
#
# The following depends on EventVMMC.m_vmmcscheduleDist.dist.type = discrete.inline
# EventVMMC.m_vmmcscheduleDist.dist.discrete.inline.xvalues
# EventVMMC.m_vmmcscheduleDist.dist.discrete.inline.yvalues
# EventVMMC.m_vmmcscheduleDist.dist.discrete.inline.floor
#
# The following depends on EventVMMC.m_vmmcscheduleDist.dist.type = exponential
# EventVMMC.m_vmmcscheduleDist.dist.exponential.lambda
#
# The following depends on EventVMMC.m_vmmcscheduleDist.dist.type = fixed
# EventVMMC.m_vmmcscheduleDist.dist.fixed.value
#
# The following depends on EventVMMC.m_vmmcscheduleDist.dist.type = gamma
# EventVMMC.m_vmmcscheduleDist.dist.gamma.a
# EventVMMC.m_vmmcscheduleDist.dist.gamma.b
#
# The following depends on EventVMMC.m_vmmcscheduleDist.dist.type = lognormal
# EventVMMC.m_vmmcscheduleDist.dist.lognormal.zeta
# EventVMMC.m_vmmcscheduleDist.dist.lognormal.sigma
#
# The following depends on EventVMMC.m_vmmcscheduleDist.dist.type = normal
# EventVMMC.m_vmmcscheduleDist.dist.normal.mu
# EventVMMC.m_vmmcscheduleDist.dist.normal.sigma
# EventVMMC.m_vmmcscheduleDist.dist.normal.min
# EventVMMC.m_vmmcscheduleDist.dist.normal.max
#
# The following depends on EventVMMC.m_vmmcscheduleDist.dist.type = uniform
# EventVMMC.m_vmmcscheduleDist.dist.uniform.min
# EventVMMC.m_vmmcscheduleDist.dist.uniform.max
#
# The following depends on person.art.accept.threshold.dist.type = beta
# person.art.accept.threshold.dist.beta.a
# person.art.accept.threshold.dist.beta.b
# person.art.accept.threshold.dist.beta.min
# person.art.accept.threshold.dist.beta.max
#
# The following depends on person.art.accept.threshold.dist.type = discrete.csv.onecol
# person.art.accept.threshold.dist.discrete.csv.onecol.file
# person.art.accept.threshold.dist.discrete.csv.onecol.xmin
# person.art.accept.threshold.dist.discrete.csv.onecol.xmax
# person.art.accept.threshold.dist.discrete.csv.onecol.ycolumn
# person.art.accept.threshold.dist.discrete.csv.onecol.floor
#
# The following depends on person.art.accept.threshold.dist.type = discrete.csv.twocol
# person.art.accept.threshold.dist.discrete.csv.twocol.file
# person.art.accept.threshold.dist.discrete.csv.twocol.xcolumn
# person.art.accept.threshold.dist.discrete.csv.twocol.ycolumn
# person.art.accept.threshold.dist.discrete.csv.twocol.floor
#
# The following depends on person.art.accept.threshold.dist.type = discrete.inline
# person.art.accept.threshold.dist.discrete.inline.xvalues
# person.art.accept.threshold.dist.discrete.inline.yvalues
# person.art.accept.threshold.dist.discrete.inline.floor
#
# The following depends on person.art.accept.threshold.dist.type = exponential
# person.art.accept.threshold.dist.exponential.lambda
#
# The following depends on person.art.accept.threshold.dist.type = gamma
# person.art.accept.threshold.dist.gamma.a
# person.art.accept.threshold.dist.gamma.b
#
# The following depends on person.art.accept.threshold.dist.type = lognormal
# person.art.accept.threshold.dist.lognormal.zeta
# person.art.accept.threshold.dist.lognormal.sigma
#
# The following depends on person.art.accept.threshold.dist.type = normal
# person.art.accept.threshold.dist.normal.mu
# person.art.accept.threshold.dist.normal.sigma
# person.art.accept.threshold.dist.normal.min
# person.art.accept.threshold.dist.normal.max
#
# The following depends on person.art.accept.threshold.dist.type = uniform
# person.art.accept.threshold.dist.uniform.min
# person.art.accept.threshold.dist.uniform.max
#
# The following depends on person.agegap.man.msm.dist.type = beta
# person.agegap.man.msm.dist.beta.a
# person.agegap.man.msm.dist.beta.b
# person.agegap.man.msm.dist.beta.min
# person.agegap.man.msm.dist.beta.max
#
# The following depends on person.agegap.man.msm.dist.type = discrete.csv.onecol
# person.agegap.man.msm.dist.discrete.csv.onecol.file
# person.agegap.man.msm.dist.discrete.csv.onecol.xmin
# person.agegap.man.msm.dist.discrete.csv.onecol.xmax
# person.agegap.man.msm.dist.discrete.csv.onecol.ycolumn
# person.agegap.man.msm.dist.discrete.csv.onecol.floor
#
# The following depends on person.agegap.man.msm.dist.type = discrete.csv.twocol
# person.agegap.man.msm.dist.discrete.csv.twocol.file
# person.agegap.man.msm.dist.discrete.csv.twocol.xcolumn
# person.agegap.man.msm.dist.discrete.csv.twocol.ycolumn
# person.agegap.man.msm.dist.discrete.csv.twocol.floor
#
# The following depends on person.agegap.man.msm.dist.type = discrete.inline
# person.agegap.man.msm.dist.discrete.inline.xvalues
# person.agegap.man.msm.dist.discrete.inline.yvalues
# person.agegap.man.msm.dist.discrete.inline.floor
#
# The following depends on person.agegap.man.msm.dist.type = exponential
# person.agegap.man.msm.dist.exponential.lambda
#
# The following depends on person.agegap.man.msm.dist.type = gamma
# person.agegap.man.msm.dist.gamma.a
# person.agegap.man.msm.dist.gamma.b
#
# The following depends on person.agegap.man.msm.dist.type = lognormal
# person.agegap.man.msm.dist.lognormal.zeta
# person.agegap.man.msm.dist.lognormal.sigma
#
# The following depends on person.agegap.man.msm.dist.type = normal
# person.agegap.man.msm.dist.normal.mu
# person.agegap.man.msm.dist.normal.sigma
# person.agegap.man.msm.dist.normal.min
# person.agegap.man.msm.dist.normal.max
#
# The following depends on person.agegap.man.msm.dist.type = uniform
# person.agegap.man.msm.dist.uniform.min
# person.agegap.man.msm.dist.uniform.max
#
# The following depends on person.agegap.man.dist.type = beta
# person.agegap.man.dist.beta.a
# person.agegap.man.dist.beta.b
# person.agegap.man.dist.beta.min
# person.agegap.man.dist.beta.max
#
# The following depends on person.agegap.man.dist.type = discrete.csv.onecol
# person.agegap.man.dist.discrete.csv.onecol.file
# person.agegap.man.dist.discrete.csv.onecol.xmin
# person.agegap.man.dist.discrete.csv.onecol.xmax
# person.agegap.man.dist.discrete.csv.onecol.ycolumn
# person.agegap.man.dist.discrete.csv.onecol.floor
#
# The following depends on person.agegap.man.dist.type = discrete.csv.twocol
# person.agegap.man.dist.discrete.csv.twocol.file
# person.agegap.man.dist.discrete.csv.twocol.xcolumn
# person.agegap.man.dist.discrete.csv.twocol.ycolumn
# person.agegap.man.dist.discrete.csv.twocol.floor
#
# The following depends on person.agegap.man.dist.type = discrete.inline
# person.agegap.man.dist.discrete.inline.xvalues
# person.agegap.man.dist.discrete.inline.yvalues
# person.agegap.man.dist.discrete.inline.floor
#
# The following depends on person.agegap.man.dist.type = exponential
# person.agegap.man.dist.exponential.lambda
#
# The following depends on person.agegap.man.dist.type = fixed
# person.agegap.man.dist.fixed.value
#
# The following depends on person.agegap.man.dist.type = gamma
# person.agegap.man.dist.gamma.a
# person.agegap.man.dist.gamma.b
#
# The following depends on person.agegap.man.dist.type = lognormal
# person.agegap.man.dist.lognormal.zeta
# person.agegap.man.dist.lognormal.sigma
#
# The following depends on person.agegap.man.dist.type = uniform
# person.agegap.man.dist.uniform.min
# person.agegap.man.dist.uniform.max
#
# The following depends on person.agegap.woman.wsw.dist.type = beta
# person.agegap.woman.wsw.dist.beta.a
# person.agegap.woman.wsw.dist.beta.b
# person.agegap.woman.wsw.dist.beta.min
# person.agegap.woman.wsw.dist.beta.max
#
# The following depends on person.agegap.woman.wsw.dist.type = discrete.csv.onecol
# person.agegap.woman.wsw.dist.discrete.csv.onecol.file
# person.agegap.woman.wsw.dist.discrete.csv.onecol.xmin
# person.agegap.woman.wsw.dist.discrete.csv.onecol.xmax
# person.agegap.woman.wsw.dist.discrete.csv.onecol.ycolumn
# person.agegap.woman.wsw.dist.discrete.csv.onecol.floor
#
# The following depends on person.agegap.woman.wsw.dist.type = discrete.csv.twocol
# person.agegap.woman.wsw.dist.discrete.csv.twocol.file
# person.agegap.woman.wsw.dist.discrete.csv.twocol.xcolumn
# person.agegap.woman.wsw.dist.discrete.csv.twocol.ycolumn
# person.agegap.woman.wsw.dist.discrete.csv.twocol.floor
#
# The following depends on person.agegap.woman.wsw.dist.type = discrete.inline
# person.agegap.woman.wsw.dist.discrete.inline.xvalues
# person.agegap.woman.wsw.dist.discrete.inline.yvalues
# person.agegap.woman.wsw.dist.discrete.inline.floor
#
# The following depends on person.agegap.woman.wsw.dist.type = exponential
# person.agegap.woman.wsw.dist.exponential.lambda
#
# The following depends on person.agegap.woman.wsw.dist.type = gamma
# person.agegap.woman.wsw.dist.gamma.a
# person.agegap.woman.wsw.dist.gamma.b
#
# The following depends on person.agegap.woman.wsw.dist.type = lognormal
# person.agegap.woman.wsw.dist.lognormal.zeta
# person.agegap.woman.wsw.dist.lognormal.sigma
#
# The following depends on person.agegap.woman.wsw.dist.type = normal
# person.agegap.woman.wsw.dist.normal.mu
# person.agegap.woman.wsw.dist.normal.sigma
# person.agegap.woman.wsw.dist.normal.min
# person.agegap.woman.wsw.dist.normal.max
#
# The following depends on person.agegap.woman.wsw.dist.type = uniform
# person.agegap.woman.wsw.dist.uniform.min
# person.agegap.woman.wsw.dist.uniform.max
#
# The following depends on person.agegap.woman.dist.type = beta
# person.agegap.woman.dist.beta.a
# person.agegap.woman.dist.beta.b
# person.agegap.woman.dist.beta.min
# person.agegap.woman.dist.beta.max
#
# The following depends on person.agegap.woman.dist.type = discrete.csv.onecol
# person.agegap.woman.dist.discrete.csv.onecol.file
# person.agegap.woman.dist.discrete.csv.onecol.xmin
# person.agegap.woman.dist.discrete.csv.onecol.xmax
# person.agegap.woman.dist.discrete.csv.onecol.ycolumn
# person.agegap.woman.dist.discrete.csv.onecol.floor
#
# The following depends on person.agegap.woman.dist.type = discrete.csv.twocol
# person.agegap.woman.dist.discrete.csv.twocol.file
# person.agegap.woman.dist.discrete.csv.twocol.xcolumn
# person.agegap.woman.dist.discrete.csv.twocol.ycolumn
# person.agegap.woman.dist.discrete.csv.twocol.floor
#
# The following depends on person.agegap.woman.dist.type = discrete.inline
# person.agegap.woman.dist.discrete.inline.xvalues
# person.agegap.woman.dist.discrete.inline.yvalues
# person.agegap.woman.dist.discrete.inline.floor
#
# The following depends on person.agegap.woman.dist.type = exponential
# person.agegap.woman.dist.exponential.lambda
#
# The following depends on person.agegap.woman.dist.type = fixed
# person.agegap.woman.dist.fixed.value
#
# The following depends on person.agegap.woman.dist.type = gamma
# person.agegap.woman.dist.gamma.a
# person.agegap.woman.dist.gamma.b
#
# The following depends on person.agegap.woman.dist.type = lognormal
# person.agegap.woman.dist.lognormal.zeta
# person.agegap.woman.dist.lognormal.sigma
#
# The following depends on person.agegap.woman.dist.type = uniform
# person.agegap.woman.dist.uniform.min
# person.agegap.woman.dist.uniform.max
#
# The following depends on person.cd4.start.dist.type = beta
# person.cd4.start.dist.beta.a
# person.cd4.start.dist.beta.b
# person.cd4.start.dist.beta.min
# person.cd4.start.dist.beta.max
#
# The following depends on person.cd4.start.dist.type = discrete.csv.onecol
# person.cd4.start.dist.discrete.csv.onecol.file
# person.cd4.start.dist.discrete.csv.onecol.xmin
# person.cd4.start.dist.discrete.csv.onecol.xmax
# person.cd4.start.dist.discrete.csv.onecol.ycolumn
# person.cd4.start.dist.discrete.csv.onecol.floor
#
# The following depends on person.cd4.start.dist.type = discrete.csv.twocol
# person.cd4.start.dist.discrete.csv.twocol.file
# person.cd4.start.dist.discrete.csv.twocol.xcolumn
# person.cd4.start.dist.discrete.csv.twocol.ycolumn
# person.cd4.start.dist.discrete.csv.twocol.floor
#
# The following depends on person.cd4.start.dist.type = discrete.inline
# person.cd4.start.dist.discrete.inline.xvalues
# person.cd4.start.dist.discrete.inline.yvalues
# person.cd4.start.dist.discrete.inline.floor
#
# The following depends on person.cd4.start.dist.type = exponential
# person.cd4.start.dist.exponential.lambda
#
# The following depends on person.cd4.start.dist.type = fixed
# person.cd4.start.dist.fixed.value
#
# The following depends on person.cd4.start.dist.type = gamma
# person.cd4.start.dist.gamma.a
# person.cd4.start.dist.gamma.b
#
# The following depends on person.cd4.start.dist.type = normal
# person.cd4.start.dist.normal.mu
# person.cd4.start.dist.normal.sigma
# person.cd4.start.dist.normal.min
# person.cd4.start.dist.normal.max
#
# The following depends on person.cd4.start.dist.type = uniform
# person.cd4.start.dist.uniform.min
# person.cd4.start.dist.uniform.max
#
# The following depends on person.cd4.end.dist.type = beta
# person.cd4.end.dist.beta.a
# person.cd4.end.dist.beta.b
# person.cd4.end.dist.beta.min
# person.cd4.end.dist.beta.max
#
# The following depends on person.cd4.end.dist.type = discrete.csv.onecol
# person.cd4.end.dist.discrete.csv.onecol.file
# person.cd4.end.dist.discrete.csv.onecol.xmin
# person.cd4.end.dist.discrete.csv.onecol.xmax
# person.cd4.end.dist.discrete.csv.onecol.ycolumn
# person.cd4.end.dist.discrete.csv.onecol.floor
#
# The following depends on person.cd4.end.dist.type = discrete.csv.twocol
# person.cd4.end.dist.discrete.csv.twocol.file
# person.cd4.end.dist.discrete.csv.twocol.xcolumn
# person.cd4.end.dist.discrete.csv.twocol.ycolumn
# person.cd4.end.dist.discrete.csv.twocol.floor
#
# The following depends on person.cd4.end.dist.type = discrete.inline
# person.cd4.end.dist.discrete.inline.xvalues
# person.cd4.end.dist.discrete.inline.yvalues
# person.cd4.end.dist.discrete.inline.floor
#
# The following depends on person.cd4.end.dist.type = exponential
# person.cd4.end.dist.exponential.lambda
#
# The following depends on person.cd4.end.dist.type = fixed
# person.cd4.end.dist.fixed.value
#
# The following depends on person.cd4.end.dist.type = gamma
# person.cd4.end.dist.gamma.a
# person.cd4.end.dist.gamma.b
#
# The following depends on person.cd4.end.dist.type = normal
# person.cd4.end.dist.normal.mu
# person.cd4.end.dist.normal.sigma
# person.cd4.end.dist.normal.min
# person.cd4.end.dist.normal.max
#
# The following depends on person.cd4.end.dist.type = uniform
# person.cd4.end.dist.uniform.min
# person.cd4.end.dist.uniform.max
#
# The following depends on person.eagerness.man.type = joint
# person.eagerness.man.joint.dist2d.type
#
# The following depends on person.eagerness.man.joint.dist2d.type = binormal
# person.eagerness.man.joint.dist2d.binormal.meanx
# person.eagerness.man.joint.dist2d.binormal.meany
# person.eagerness.man.joint.dist2d.binormal.sigmax
# person.eagerness.man.joint.dist2d.binormal.sigmay
# person.eagerness.man.joint.dist2d.binormal.rho
# person.eagerness.man.joint.dist2d.binormal.minx
# person.eagerness.man.joint.dist2d.binormal.maxx
# person.eagerness.man.joint.dist2d.binormal.miny
# person.eagerness.man.joint.dist2d.binormal.maxy
#
# The following depends on person.eagerness.man.joint.dist2d.type = binormalsymm
# person.eagerness.man.joint.dist2d.binormalsymm.mean
# person.eagerness.man.joint.dist2d.binormalsymm.sigma
# person.eagerness.man.joint.dist2d.binormalsymm.rho
# person.eagerness.man.joint.dist2d.binormalsymm.min
# person.eagerness.man.joint.dist2d.binormalsymm.max
#
# The following depends on person.eagerness.man.joint.dist2d.type = discrete
# person.eagerness.man.joint.dist2d.discrete.densfile
# person.eagerness.man.joint.dist2d.discrete.maskfile
# person.eagerness.man.joint.dist2d.discrete.xoffset
# person.eagerness.man.joint.dist2d.discrete.yoffset
# person.eagerness.man.joint.dist2d.discrete.width
# person.eagerness.man.joint.dist2d.discrete.height
# person.eagerness.man.joint.dist2d.discrete.flipy
# person.eagerness.man.joint.dist2d.discrete.floor
#
# The following depends on person.eagerness.man.joint.dist2d.type = fixed
# person.eagerness.man.joint.dist2d.fixed.xvalue
# person.eagerness.man.joint.dist2d.fixed.yvalue
#
# The following depends on person.eagerness.man.joint.dist2d.type = uniform
# person.eagerness.man.joint.dist2d.uniform.xmin
# person.eagerness.man.joint.dist2d.uniform.xmax
# person.eagerness.man.joint.dist2d.uniform.ymin
# person.eagerness.man.joint.dist2d.uniform.ymax
#
# The following depends on person.eagerness.man.msm.dist.type = beta
# person.eagerness.man.msm.dist.beta.a
# person.eagerness.man.msm.dist.beta.b
# person.eagerness.man.msm.dist.beta.min
# person.eagerness.man.msm.dist.beta.max
#
# The following depends on person.eagerness.man.msm.dist.type = discrete.csv.onecol
# person.eagerness.man.msm.dist.discrete.csv.onecol.file
# person.eagerness.man.msm.dist.discrete.csv.onecol.xmin
# person.eagerness.man.msm.dist.discrete.csv.onecol.xmax
# person.eagerness.man.msm.dist.discrete.csv.onecol.ycolumn
# person.eagerness.man.msm.dist.discrete.csv.onecol.floor
#
# The following depends on person.eagerness.man.msm.dist.type = discrete.csv.twocol
# person.eagerness.man.msm.dist.discrete.csv.twocol.file
# person.eagerness.man.msm.dist.discrete.csv.twocol.xcolumn
# person.eagerness.man.msm.dist.discrete.csv.twocol.ycolumn
# person.eagerness.man.msm.dist.discrete.csv.twocol.floor
#
# The following depends on person.eagerness.man.msm.dist.type = discrete.inline
# person.eagerness.man.msm.dist.discrete.inline.xvalues
# person.eagerness.man.msm.dist.discrete.inline.yvalues
# person.eagerness.man.msm.dist.discrete.inline.floor
#
# The following depends on person.eagerness.man.msm.dist.type = exponential
# person.eagerness.man.msm.dist.exponential.lambda
#
# The following depends on person.eagerness.man.msm.dist.type = gamma
# person.eagerness.man.msm.dist.gamma.a
# person.eagerness.man.msm.dist.gamma.b
#
# The following depends on person.eagerness.man.msm.dist.type = lognormal
# person.eagerness.man.msm.dist.lognormal.zeta
# person.eagerness.man.msm.dist.lognormal.sigma
#
# The following depends on person.eagerness.man.msm.dist.type = normal
# person.eagerness.man.msm.dist.normal.mu
# person.eagerness.man.msm.dist.normal.sigma
# person.eagerness.man.msm.dist.normal.min
# person.eagerness.man.msm.dist.normal.max
#
# The following depends on person.eagerness.man.msm.dist.type = uniform
# person.eagerness.man.msm.dist.uniform.min
# person.eagerness.man.msm.dist.uniform.max
#
# The following depends on person.eagerness.man.dist.type = beta
# person.eagerness.man.dist.beta.a
# person.eagerness.man.dist.beta.b
# person.eagerness.man.dist.beta.min
# person.eagerness.man.dist.beta.max
#
# The following depends on person.eagerness.man.dist.type = discrete.csv.onecol
# person.eagerness.man.dist.discrete.csv.onecol.file
# person.eagerness.man.dist.discrete.csv.onecol.xmin
# person.eagerness.man.dist.discrete.csv.onecol.xmax
# person.eagerness.man.dist.discrete.csv.onecol.ycolumn
# person.eagerness.man.dist.discrete.csv.onecol.floor
#
# The following depends on person.eagerness.man.dist.type = discrete.csv.twocol
# person.eagerness.man.dist.discrete.csv.twocol.file
# person.eagerness.man.dist.discrete.csv.twocol.xcolumn
# person.eagerness.man.dist.discrete.csv.twocol.ycolumn
# person.eagerness.man.dist.discrete.csv.twocol.floor
#
# The following depends on person.eagerness.man.dist.type = discrete.inline
# person.eagerness.man.dist.discrete.inline.xvalues
# person.eagerness.man.dist.discrete.inline.yvalues
# person.eagerness.man.dist.discrete.inline.floor
#
# The following depends on person.eagerness.man.dist.type = exponential
# person.eagerness.man.dist.exponential.lambda
#
# The following depends on person.eagerness.man.dist.type = fixed
# person.eagerness.man.dist.fixed.value
#
# The following depends on person.eagerness.man.dist.type = lognormal
# person.eagerness.man.dist.lognormal.zeta
# person.eagerness.man.dist.lognormal.sigma
#
# The following depends on person.eagerness.man.dist.type = normal
# person.eagerness.man.dist.normal.mu
# person.eagerness.man.dist.normal.sigma
# person.eagerness.man.dist.normal.min
# person.eagerness.man.dist.normal.max
#
# The following depends on person.eagerness.man.dist.type = uniform
# person.eagerness.man.dist.uniform.min
# person.eagerness.man.dist.uniform.max
#
# The following depends on person.eagerness.woman.type = joint
# person.eagerness.woman.joint.dist2d.type
#
# The following depends on person.eagerness.woman.joint.dist2d.type = binormal
# person.eagerness.woman.joint.dist2d.binormal.meanx
# person.eagerness.woman.joint.dist2d.binormal.meany
# person.eagerness.woman.joint.dist2d.binormal.sigmax
# person.eagerness.woman.joint.dist2d.binormal.sigmay
# person.eagerness.woman.joint.dist2d.binormal.rho
# person.eagerness.woman.joint.dist2d.binormal.minx
# person.eagerness.woman.joint.dist2d.binormal.maxx
# person.eagerness.woman.joint.dist2d.binormal.miny
# person.eagerness.woman.joint.dist2d.binormal.maxy
#
# The following depends on person.eagerness.woman.joint.dist2d.type = binormalsymm
# person.eagerness.woman.joint.dist2d.binormalsymm.mean
# person.eagerness.woman.joint.dist2d.binormalsymm.sigma
# person.eagerness.woman.joint.dist2d.binormalsymm.rho
# person.eagerness.woman.joint.dist2d.binormalsymm.min
# person.eagerness.woman.joint.dist2d.binormalsymm.max
#
# The following depends on person.eagerness.woman.joint.dist2d.type = discrete
# person.eagerness.woman.joint.dist2d.discrete.densfile
# person.eagerness.woman.joint.dist2d.discrete.maskfile
# person.eagerness.woman.joint.dist2d.discrete.xoffset
# person.eagerness.woman.joint.dist2d.discrete.yoffset
# person.eagerness.woman.joint.dist2d.discrete.width
# person.eagerness.woman.joint.dist2d.discrete.height
# person.eagerness.woman.joint.dist2d.discrete.flipy
# person.eagerness.woman.joint.dist2d.discrete.floor
#
# The following depends on person.eagerness.woman.joint.dist2d.type = fixed
# person.eagerness.woman.joint.dist2d.fixed.xvalue
# person.eagerness.woman.joint.dist2d.fixed.yvalue
#
# The following depends on person.eagerness.woman.joint.dist2d.type = uniform
# person.eagerness.woman.joint.dist2d.uniform.xmin
# person.eagerness.woman.joint.dist2d.uniform.xmax
# person.eagerness.woman.joint.dist2d.uniform.ymin
# person.eagerness.woman.joint.dist2d.uniform.ymax
#
# The following depends on person.eagerness.woman.wsw.dist.type = beta
# person.eagerness.woman.wsw.dist.beta.a
# person.eagerness.woman.wsw.dist.beta.b
# person.eagerness.woman.wsw.dist.beta.min
# person.eagerness.woman.wsw.dist.beta.max
#
# The following depends on person.eagerness.woman.wsw.dist.type = discrete.csv.onecol
# person.eagerness.woman.wsw.dist.discrete.csv.onecol.file
# person.eagerness.woman.wsw.dist.discrete.csv.onecol.xmin
# person.eagerness.woman.wsw.dist.discrete.csv.onecol.xmax
# person.eagerness.woman.wsw.dist.discrete.csv.onecol.ycolumn
# person.eagerness.woman.wsw.dist.discrete.csv.onecol.floor
#
# The following depends on person.eagerness.woman.wsw.dist.type = discrete.csv.twocol
# person.eagerness.woman.wsw.dist.discrete.csv.twocol.file
# person.eagerness.woman.wsw.dist.discrete.csv.twocol.xcolumn
# person.eagerness.woman.wsw.dist.discrete.csv.twocol.ycolumn
# person.eagerness.woman.wsw.dist.discrete.csv.twocol.floor
#
# The following depends on person.eagerness.woman.wsw.dist.type = discrete.inline
# person.eagerness.woman.wsw.dist.discrete.inline.xvalues
# person.eagerness.woman.wsw.dist.discrete.inline.yvalues
# person.eagerness.woman.wsw.dist.discrete.inline.floor
#
# The following depends on person.eagerness.woman.wsw.dist.type = exponential
# person.eagerness.woman.wsw.dist.exponential.lambda
#
# The following depends on person.eagerness.woman.wsw.dist.type = gamma
# person.eagerness.woman.wsw.dist.gamma.a
# person.eagerness.woman.wsw.dist.gamma.b
#
# The following depends on person.eagerness.woman.wsw.dist.type = lognormal
# person.eagerness.woman.wsw.dist.lognormal.zeta
# person.eagerness.woman.wsw.dist.lognormal.sigma
#
# The following depends on person.eagerness.woman.wsw.dist.type = normal
# person.eagerness.woman.wsw.dist.normal.mu
# person.eagerness.woman.wsw.dist.normal.sigma
# person.eagerness.woman.wsw.dist.normal.min
# person.eagerness.woman.wsw.dist.normal.max
#
# The following depends on person.eagerness.woman.wsw.dist.type = uniform
# person.eagerness.woman.wsw.dist.uniform.min
# person.eagerness.woman.wsw.dist.uniform.max
#
# The following depends on person.eagerness.woman.dist.type = beta
# person.eagerness.woman.dist.beta.a
# person.eagerness.woman.dist.beta.b
# person.eagerness.woman.dist.beta.min
# person.eagerness.woman.dist.beta.max
#
# The following depends on person.eagerness.woman.dist.type = discrete.csv.onecol
# person.eagerness.woman.dist.discrete.csv.onecol.file
# person.eagerness.woman.dist.discrete.csv.onecol.xmin
# person.eagerness.woman.dist.discrete.csv.onecol.xmax
# person.eagerness.woman.dist.discrete.csv.onecol.ycolumn
# person.eagerness.woman.dist.discrete.csv.onecol.floor
#
# The following depends on person.eagerness.woman.dist.type = discrete.csv.twocol
# person.eagerness.woman.dist.discrete.csv.twocol.file
# person.eagerness.woman.dist.discrete.csv.twocol.xcolumn
# person.eagerness.woman.dist.discrete.csv.twocol.ycolumn
# person.eagerness.woman.dist.discrete.csv.twocol.floor
#
# The following depends on person.eagerness.woman.dist.type = discrete.inline
# person.eagerness.woman.dist.discrete.inline.xvalues
# person.eagerness.woman.dist.discrete.inline.yvalues
# person.eagerness.woman.dist.discrete.inline.floor
#
# The following depends on person.eagerness.woman.dist.type = exponential
# person.eagerness.woman.dist.exponential.lambda
#
# The following depends on person.eagerness.woman.dist.type = fixed
# person.eagerness.woman.dist.fixed.value
#
# The following depends on person.eagerness.woman.dist.type = lognormal
# person.eagerness.woman.dist.lognormal.zeta
# person.eagerness.woman.dist.lognormal.sigma
#
# The following depends on person.eagerness.woman.dist.type = normal
# person.eagerness.woman.dist.normal.mu
# person.eagerness.woman.dist.normal.sigma
# person.eagerness.woman.dist.normal.min
# person.eagerness.woman.dist.normal.max
#
# The following depends on person.eagerness.woman.dist.type = uniform
# person.eagerness.woman.dist.uniform.min
# person.eagerness.woman.dist.uniform.max
#
# The following depends on person.geo.dist2d.type = binormal
# person.geo.dist2d.binormal.meanx
# person.geo.dist2d.binormal.meany
# person.geo.dist2d.binormal.sigmax
# person.geo.dist2d.binormal.sigmay
# person.geo.dist2d.binormal.rho
# person.geo.dist2d.binormal.minx
# person.geo.dist2d.binormal.maxx
# person.geo.dist2d.binormal.miny
# person.geo.dist2d.binormal.maxy
#
# The following depends on person.geo.dist2d.type = binormalsymm
# person.geo.dist2d.binormalsymm.mean
# person.geo.dist2d.binormalsymm.sigma
# person.geo.dist2d.binormalsymm.rho
# person.geo.dist2d.binormalsymm.min
# person.geo.dist2d.binormalsymm.max
#
# The following depends on person.geo.dist2d.type = discrete
# person.geo.dist2d.discrete.densfile
# person.geo.dist2d.discrete.maskfile
# person.geo.dist2d.discrete.xoffset
# person.geo.dist2d.discrete.yoffset
# person.geo.dist2d.discrete.width
# person.geo.dist2d.discrete.height
# person.geo.dist2d.discrete.flipy
# person.geo.dist2d.discrete.floor
#
# The following depends on person.geo.dist2d.type = uniform
# person.geo.dist2d.uniform.xmin
# person.geo.dist2d.uniform.xmax
# person.geo.dist2d.uniform.ymin
# person.geo.dist2d.uniform.ymax
#
# The following depends on person.hiv.b0.dist.type = beta
# person.hiv.b0.dist.beta.a
# person.hiv.b0.dist.beta.b
# person.hiv.b0.dist.beta.min
# person.hiv.b0.dist.beta.max
#
# The following depends on person.hiv.b0.dist.type = discrete.csv.onecol
# person.hiv.b0.dist.discrete.csv.onecol.file
# person.hiv.b0.dist.discrete.csv.onecol.xmin
# person.hiv.b0.dist.discrete.csv.onecol.xmax
# person.hiv.b0.dist.discrete.csv.onecol.ycolumn
# person.hiv.b0.dist.discrete.csv.onecol.floor
#
# The following depends on person.hiv.b0.dist.type = discrete.csv.twocol
# person.hiv.b0.dist.discrete.csv.twocol.file
# person.hiv.b0.dist.discrete.csv.twocol.xcolumn
# person.hiv.b0.dist.discrete.csv.twocol.ycolumn
# person.hiv.b0.dist.discrete.csv.twocol.floor
#
# The following depends on person.hiv.b0.dist.type = discrete.inline
# person.hiv.b0.dist.discrete.inline.xvalues
# person.hiv.b0.dist.discrete.inline.yvalues
# person.hiv.b0.dist.discrete.inline.floor
#
# The following depends on person.hiv.b0.dist.type = exponential
# person.hiv.b0.dist.exponential.lambda
#
# The following depends on person.hiv.b0.dist.type = gamma
# person.hiv.b0.dist.gamma.a
# person.hiv.b0.dist.gamma.b
#
# The following depends on person.hiv.b0.dist.type = lognormal
# person.hiv.b0.dist.lognormal.zeta
# person.hiv.b0.dist.lognormal.sigma
#
# The following depends on person.hiv.b0.dist.type = normal
# person.hiv.b0.dist.normal.mu
# person.hiv.b0.dist.normal.sigma
# person.hiv.b0.dist.normal.min
# person.hiv.b0.dist.normal.max
#
# The following depends on person.hiv.b0.dist.type = uniform
# person.hiv.b0.dist.uniform.min
# person.hiv.b0.dist.uniform.max
#
# The following depends on person.hiv.b1.dist.type = beta
# person.hiv.b1.dist.beta.a
# person.hiv.b1.dist.beta.b
# person.hiv.b1.dist.beta.min
# person.hiv.b1.dist.beta.max
#
# The following depends on person.hiv.b1.dist.type = discrete.csv.onecol
# person.hiv.b1.dist.discrete.csv.onecol.file
# person.hiv.b1.dist.discrete.csv.onecol.xmin
# person.hiv.b1.dist.discrete.csv.onecol.xmax
# person.hiv.b1.dist.discrete.csv.onecol.ycolumn
# person.hiv.b1.dist.discrete.csv.onecol.floor
#
# The following depends on person.hiv.b1.dist.type = discrete.csv.twocol
# person.hiv.b1.dist.discrete.csv.twocol.file
# person.hiv.b1.dist.discrete.csv.twocol.xcolumn
# person.hiv.b1.dist.discrete.csv.twocol.ycolumn
# person.hiv.b1.dist.discrete.csv.twocol.floor
#
# The following depends on person.hiv.b1.dist.type = discrete.inline
# person.hiv.b1.dist.discrete.inline.xvalues
# person.hiv.b1.dist.discrete.inline.yvalues
# person.hiv.b1.dist.discrete.inline.floor
#
# The following depends on person.hiv.b1.dist.type = exponential
# person.hiv.b1.dist.exponential.lambda
#
# The following depends on person.hiv.b1.dist.type = gamma
# person.hiv.b1.dist.gamma.a
# person.hiv.b1.dist.gamma.b
#
# The following depends on person.hiv.b1.dist.type = lognormal
# person.hiv.b1.dist.lognormal.zeta
# person.hiv.b1.dist.lognormal.sigma
#
# The following depends on person.hiv.b1.dist.type = normal
# person.hiv.b1.dist.normal.mu
# person.hiv.b1.dist.normal.sigma
# person.hiv.b1.dist.normal.min
# person.hiv.b1.dist.normal.max
#
# The following depends on person.hiv.b1.dist.type = uniform
# person.hiv.b1.dist.uniform.min
# person.hiv.b1.dist.uniform.max
#
# The following depends on person.hsv2.a.dist.type = beta
# person.hsv2.a.dist.beta.a
# person.hsv2.a.dist.beta.b
# person.hsv2.a.dist.beta.min
# person.hsv2.a.dist.beta.max
#
# The following depends on person.hsv2.a.dist.type = discrete.csv.onecol
# person.hsv2.a.dist.discrete.csv.onecol.file
# person.hsv2.a.dist.discrete.csv.onecol.xmin
# person.hsv2.a.dist.discrete.csv.onecol.xmax
# person.hsv2.a.dist.discrete.csv.onecol.ycolumn
# person.hsv2.a.dist.discrete.csv.onecol.floor
#
# The following depends on person.hsv2.a.dist.type = discrete.csv.twocol
# person.hsv2.a.dist.discrete.csv.twocol.file
# person.hsv2.a.dist.discrete.csv.twocol.xcolumn
# person.hsv2.a.dist.discrete.csv.twocol.ycolumn
# person.hsv2.a.dist.discrete.csv.twocol.floor
#
# The following depends on person.hsv2.a.dist.type = discrete.inline
# person.hsv2.a.dist.discrete.inline.xvalues
# person.hsv2.a.dist.discrete.inline.yvalues
# person.hsv2.a.dist.discrete.inline.floor
#
# The following depends on person.hsv2.a.dist.type = exponential
# person.hsv2.a.dist.exponential.lambda
#
# The following depends on person.hsv2.a.dist.type = gamma
# person.hsv2.a.dist.gamma.a
# person.hsv2.a.dist.gamma.b
#
# The following depends on person.hsv2.a.dist.type = lognormal
# person.hsv2.a.dist.lognormal.zeta
# person.hsv2.a.dist.lognormal.sigma
#
# The following depends on person.hsv2.a.dist.type = normal
# person.hsv2.a.dist.normal.mu
# person.hsv2.a.dist.normal.sigma
# person.hsv2.a.dist.normal.min
# person.hsv2.a.dist.normal.max
#
# The following depends on person.hsv2.a.dist.type = uniform
# person.hsv2.a.dist.uniform.min
# person.hsv2.a.dist.uniform.max
#
# The following depends on person.hsv2.b2.dist.type = beta
# person.hsv2.b2.dist.beta.a
# person.hsv2.b2.dist.beta.b
# person.hsv2.b2.dist.beta.min
# person.hsv2.b2.dist.beta.max
#
# The following depends on person.hsv2.b2.dist.type = discrete.csv.onecol
# person.hsv2.b2.dist.discrete.csv.onecol.file
# person.hsv2.b2.dist.discrete.csv.onecol.xmin
# person.hsv2.b2.dist.discrete.csv.onecol.xmax
# person.hsv2.b2.dist.discrete.csv.onecol.ycolumn
# person.hsv2.b2.dist.discrete.csv.onecol.floor
#
# The following depends on person.hsv2.b2.dist.type = discrete.csv.twocol
# person.hsv2.b2.dist.discrete.csv.twocol.file
# person.hsv2.b2.dist.discrete.csv.twocol.xcolumn
# person.hsv2.b2.dist.discrete.csv.twocol.ycolumn
# person.hsv2.b2.dist.discrete.csv.twocol.floor
#
# The following depends on person.hsv2.b2.dist.type = discrete.inline
# person.hsv2.b2.dist.discrete.inline.xvalues
# person.hsv2.b2.dist.discrete.inline.yvalues
# person.hsv2.b2.dist.discrete.inline.floor
#
# The following depends on person.hsv2.b2.dist.type = exponential
# person.hsv2.b2.dist.exponential.lambda
#
# The following depends on person.hsv2.b2.dist.type = gamma
# person.hsv2.b2.dist.gamma.a
# person.hsv2.b2.dist.gamma.b
#
# The following depends on person.hsv2.b2.dist.type = lognormal
# person.hsv2.b2.dist.lognormal.zeta
# person.hsv2.b2.dist.lognormal.sigma
#
# The following depends on person.hsv2.b2.dist.type = normal
# person.hsv2.b2.dist.normal.mu
# person.hsv2.b2.dist.normal.sigma
# person.hsv2.b2.dist.normal.min
# person.hsv2.b2.dist.normal.max
#
# The following depends on person.hsv2.b2.dist.type = uniform
# person.hsv2.b2.dist.uniform.min
# person.hsv2.b2.dist.uniform.max
#
# The following depends on person.survtime.logoffset.dist.type = beta
# person.survtime.logoffset.dist.beta.a
# person.survtime.logoffset.dist.beta.b
# person.survtime.logoffset.dist.beta.min
# person.survtime.logoffset.dist.beta.max
#
# The following depends on person.survtime.logoffset.dist.type = discrete.csv.onecol
# person.survtime.logoffset.dist.discrete.csv.onecol.file
# person.survtime.logoffset.dist.discrete.csv.onecol.xmin
# person.survtime.logoffset.dist.discrete.csv.onecol.xmax
# person.survtime.logoffset.dist.discrete.csv.onecol.ycolumn
# person.survtime.logoffset.dist.discrete.csv.onecol.floor
#
# The following depends on person.survtime.logoffset.dist.type = discrete.csv.twocol
# person.survtime.logoffset.dist.discrete.csv.twocol.file
# person.survtime.logoffset.dist.discrete.csv.twocol.xcolumn
# person.survtime.logoffset.dist.discrete.csv.twocol.ycolumn
# person.survtime.logoffset.dist.discrete.csv.twocol.floor
#
# The following depends on person.survtime.logoffset.dist.type = discrete.inline
# person.survtime.logoffset.dist.discrete.inline.xvalues
# person.survtime.logoffset.dist.discrete.inline.yvalues
# person.survtime.logoffset.dist.discrete.inline.floor
#
# The following depends on person.survtime.logoffset.dist.type = exponential
# person.survtime.logoffset.dist.exponential.lambda
#
# The following depends on person.survtime.logoffset.dist.type = fixed
# person.survtime.logoffset.dist.fixed.value
#
# The following depends on person.survtime.logoffset.dist.type = gamma
# person.survtime.logoffset.dist.gamma.a
# person.survtime.logoffset.dist.gamma.b
#
# The following depends on person.survtime.logoffset.dist.type = lognormal
# person.survtime.logoffset.dist.lognormal.zeta
# person.survtime.logoffset.dist.lognormal.sigma
#
# The following depends on person.survtime.logoffset.dist.type = uniform
# person.survtime.logoffset.dist.uniform.min
# person.survtime.logoffset.dist.uniform.max
#
# The following depends on person.vsp.model.logdist2d.dist2d.type = binormal
# person.vsp.model.logdist2d.dist2d.binormal.meanx
# person.vsp.model.logdist2d.dist2d.binormal.meany
# person.vsp.model.logdist2d.dist2d.binormal.sigmax
# person.vsp.model.logdist2d.dist2d.binormal.sigmay
# person.vsp.model.logdist2d.dist2d.binormal.rho
# person.vsp.model.logdist2d.dist2d.binormal.minx
# person.vsp.model.logdist2d.dist2d.binormal.maxx
# person.vsp.model.logdist2d.dist2d.binormal.miny
# person.vsp.model.logdist2d.dist2d.binormal.maxy
#
# The following depends on person.vsp.model.logdist2d.dist2d.type = discrete
# person.vsp.model.logdist2d.dist2d.discrete.densfile
# person.vsp.model.logdist2d.dist2d.discrete.maskfile
# person.vsp.model.logdist2d.dist2d.discrete.xoffset
# person.vsp.model.logdist2d.dist2d.discrete.yoffset
# person.vsp.model.logdist2d.dist2d.discrete.width
# person.vsp.model.logdist2d.dist2d.discrete.height
# person.vsp.model.logdist2d.dist2d.discrete.flipy
# person.vsp.model.logdist2d.dist2d.discrete.floor
#
# The following depends on person.vsp.model.logdist2d.dist2d.type = fixed
# person.vsp.model.logdist2d.dist2d.fixed.xvalue
# person.vsp.model.logdist2d.dist2d.fixed.yvalue
#
# The following depends on person.vsp.model.logdist2d.dist2d.type = uniform
# person.vsp.model.logdist2d.dist2d.uniform.xmin
# person.vsp.model.logdist2d.dist2d.uniform.xmax
# person.vsp.model.logdist2d.dist2d.uniform.ymin
# person.vsp.model.logdist2d.dist2d.uniform.ymax
#
# The following depends on person.vsp.model.logdist2d.usealternativeseeddist = yes
# person.vsp.model.logdist2d.alternativeseed.dist.type
#
# The following depends on person.vsp.model.logdist2d.alternativeseed.dist.type = beta
# person.vsp.model.logdist2d.alternativeseed.dist.beta.a
# person.vsp.model.logdist2d.alternativeseed.dist.beta.b
# person.vsp.model.logdist2d.alternativeseed.dist.beta.min
# person.vsp.model.logdist2d.alternativeseed.dist.beta.max
#
# The following depends on person.vsp.model.logdist2d.alternativeseed.dist.type = discrete.csv.onecol
# person.vsp.model.logdist2d.alternativeseed.dist.discrete.csv.onecol.file
# person.vsp.model.logdist2d.alternativeseed.dist.discrete.csv.onecol.xmin
# person.vsp.model.logdist2d.alternativeseed.dist.discrete.csv.onecol.xmax
# person.vsp.model.logdist2d.alternativeseed.dist.discrete.csv.onecol.ycolumn
# person.vsp.model.logdist2d.alternativeseed.dist.discrete.csv.onecol.floor
#
# The following depends on person.vsp.model.logdist2d.alternativeseed.dist.type = discrete.csv.twocol
# person.vsp.model.logdist2d.alternativeseed.dist.discrete.csv.twocol.file
# person.vsp.model.logdist2d.alternativeseed.dist.discrete.csv.twocol.xcolumn
# person.vsp.model.logdist2d.alternativeseed.dist.discrete.csv.twocol.ycolumn
# person.vsp.model.logdist2d.alternativeseed.dist.discrete.csv.twocol.floor
#
# The following depends on person.vsp.model.logdist2d.alternativeseed.dist.type = discrete.inline
# person.vsp.model.logdist2d.alternativeseed.dist.discrete.inline.xvalues
# person.vsp.model.logdist2d.alternativeseed.dist.discrete.inline.yvalues
# person.vsp.model.logdist2d.alternativeseed.dist.discrete.inline.floor
#
# The following depends on person.vsp.model.logdist2d.alternativeseed.dist.type = exponential
# person.vsp.model.logdist2d.alternativeseed.dist.exponential.lambda
#
# The following depends on person.vsp.model.logdist2d.alternativeseed.dist.type = fixed
# person.vsp.model.logdist2d.alternativeseed.dist.fixed.value
#
# The following depends on person.vsp.model.logdist2d.alternativeseed.dist.type = gamma
# person.vsp.model.logdist2d.alternativeseed.dist.gamma.a
# person.vsp.model.logdist2d.alternativeseed.dist.gamma.b
#
# The following depends on person.vsp.model.logdist2d.alternativeseed.dist.type = lognormal
# person.vsp.model.logdist2d.alternativeseed.dist.lognormal.zeta
# person.vsp.model.logdist2d.alternativeseed.dist.lognormal.sigma
#
# The following depends on person.vsp.model.logdist2d.alternativeseed.dist.type = normal
# person.vsp.model.logdist2d.alternativeseed.dist.normal.mu
# person.vsp.model.logdist2d.alternativeseed.dist.normal.sigma
# person.vsp.model.logdist2d.alternativeseed.dist.normal.min
# person.vsp.model.logdist2d.alternativeseed.dist.normal.max
#
# The following depends on person.vsp.model.logdist2d.alternativeseed.dist.type = uniform
# person.vsp.model.logdist2d.alternativeseed.dist.uniform.min
# person.vsp.model.logdist2d.alternativeseed.dist.uniform.max
#
# The following depends on person.vsp.model.type = logweibullwithnoise
# person.vsp.model.logweibullwithnoise.weibullscale
# person.vsp.model.logweibullwithnoise.weibullshape
# person.vsp.model.logweibullwithnoise.fracsigma
# person.vsp.model.logweibullwithnoise.onnegative
#
# The following depends on EventCABDROP.m_CABDROPprobDist.dist.type = beta
# EventCABDROP.m_CABDROPprobDist.dist.beta.a
# EventCABDROP.m_CABDROPprobDist.dist.beta.b
# EventCABDROP.m_CABDROPprobDist.dist.beta.min
# EventCABDROP.m_CABDROPprobDist.dist.beta.max
#
# The following depends on EventCABDROP.m_CABDROPprobDist.dist.type = discrete.csv.onecol
# EventCABDROP.m_CABDROPprobDist.dist.discrete.csv.onecol.file
# EventCABDROP.m_CABDROPprobDist.dist.discrete.csv.onecol.xmin
# EventCABDROP.m_CABDROPprobDist.dist.discrete.csv.onecol.xmax
# EventCABDROP.m_CABDROPprobDist.dist.discrete.csv.onecol.ycolumn
# EventCABDROP.m_CABDROPprobDist.dist.discrete.csv.onecol.floor
#
# The following depends on EventCABDROP.m_CABDROPprobDist.dist.type = discrete.csv.twocol
# EventCABDROP.m_CABDROPprobDist.dist.discrete.csv.twocol.file
# EventCABDROP.m_CABDROPprobDist.dist.discrete.csv.twocol.xcolumn
# EventCABDROP.m_CABDROPprobDist.dist.discrete.csv.twocol.ycolumn
# EventCABDROP.m_CABDROPprobDist.dist.discrete.csv.twocol.floor
#
# The following depends on EventCABDROP.m_CABDROPprobDist.dist.type = discrete.inline
# EventCABDROP.m_CABDROPprobDist.dist.discrete.inline.xvalues
# EventCABDROP.m_CABDROPprobDist.dist.discrete.inline.yvalues
# EventCABDROP.m_CABDROPprobDist.dist.discrete.inline.floor
#
# The following depends on EventCABDROP.m_CABDROPprobDist.dist.type = exponential
# EventCABDROP.m_CABDROPprobDist.dist.exponential.lambda
#
# The following depends on EventCABDROP.m_CABDROPprobDist.dist.type = fixed
# EventCABDROP.m_CABDROPprobDist.dist.fixed.value
#
# The following depends on EventCABDROP.m_CABDROPprobDist.dist.type = gamma
# EventCABDROP.m_CABDROPprobDist.dist.gamma.a
# EventCABDROP.m_CABDROPprobDist.dist.gamma.b
#
# The following depends on EventCABDROP.m_CABDROPprobDist.dist.type = lognormal
# EventCABDROP.m_CABDROPprobDist.dist.lognormal.zeta
# EventCABDROP.m_CABDROPprobDist.dist.lognormal.sigma
#
# The following depends on EventCABDROP.m_CABDROPprobDist.dist.type = normal
# EventCABDROP.m_CABDROPprobDist.dist.normal.mu
# EventCABDROP.m_CABDROPprobDist.dist.normal.sigma
# EventCABDROP.m_CABDROPprobDist.dist.normal.min
# EventCABDROP.m_CABDROPprobDist.dist.normal.max
#
# The following depends on EventCAB.m_CABprobDist.dist.type = beta
# EventCAB.m_CABprobDist.dist.beta.a
# EventCAB.m_CABprobDist.dist.beta.b
# EventCAB.m_CABprobDist.dist.beta.min
# EventCAB.m_CABprobDist.dist.beta.max
#
# The following depends on EventCAB.m_CABprobDist.dist.type = discrete.csv.onecol
# EventCAB.m_CABprobDist.dist.discrete.csv.onecol.file
# EventCAB.m_CABprobDist.dist.discrete.csv.onecol.xmin
# EventCAB.m_CABprobDist.dist.discrete.csv.onecol.xmax
# EventCAB.m_CABprobDist.dist.discrete.csv.onecol.ycolumn
# EventCAB.m_CABprobDist.dist.discrete.csv.onecol.floor
#
# The following depends on EventCAB.m_CABprobDist.dist.type = discrete.csv.twocol
# EventCAB.m_CABprobDist.dist.discrete.csv.twocol.file
# EventCAB.m_CABprobDist.dist.discrete.csv.twocol.xcolumn
# EventCAB.m_CABprobDist.dist.discrete.csv.twocol.ycolumn
# EventCAB.m_CABprobDist.dist.discrete.csv.twocol.floor
#
# The following depends on EventCAB.m_CABprobDist.dist.type = discrete.inline
# EventCAB.m_CABprobDist.dist.discrete.inline.xvalues
# EventCAB.m_CABprobDist.dist.discrete.inline.yvalues
# EventCAB.m_CABprobDist.dist.discrete.inline.floor
#
# The following depends on EventCAB.m_CABprobDist.dist.type = exponential
# EventCAB.m_CABprobDist.dist.exponential.lambda
#
# The following depends on EventCAB.m_CABprobDist.dist.type = fixed
# EventCAB.m_CABprobDist.dist.fixed.value
#
# The following depends on EventCAB.m_CABprobDist.dist.type = gamma
# EventCAB.m_CABprobDist.dist.gamma.a
# EventCAB.m_CABprobDist.dist.gamma.b
#
# The following depends on EventCAB.m_CABprobDist.dist.type = lognormal
# EventCAB.m_CABprobDist.dist.lognormal.zeta
# EventCAB.m_CABprobDist.dist.lognormal.sigma
#
# The following depends on EventCAB.m_CABprobDist.dist.type = normal
# EventCAB.m_CABprobDist.dist.normal.mu
# EventCAB.m_CABprobDist.dist.normal.sigma
# EventCAB.m_CABprobDist.dist.normal.min
# EventCAB.m_CABprobDist.dist.normal.max
#
# The following depends on EventDVR.m_DVRprobDist.dist.type = beta
# EventDVR.m_DVRprobDist.dist.beta.a
# EventDVR.m_DVRprobDist.dist.beta.b
# EventDVR.m_DVRprobDist.dist.beta.min
# EventDVR.m_DVRprobDist.dist.beta.max
#
# The following depends on EventDVR.m_DVRprobDist.dist.type = discrete.csv.onecol
# EventDVR.m_DVRprobDist.dist.discrete.csv.onecol.file
# EventDVR.m_DVRprobDist.dist.discrete.csv.onecol.xmin
# EventDVR.m_DVRprobDist.dist.discrete.csv.onecol.xmax
# EventDVR.m_DVRprobDist.dist.discrete.csv.onecol.ycolumn
# EventDVR.m_DVRprobDist.dist.discrete.csv.onecol.floor
#
# The following depends on EventDVR.m_DVRprobDist.dist.type = discrete.csv.twocol
# EventDVR.m_DVRprobDist.dist.discrete.csv.twocol.file
# EventDVR.m_DVRprobDist.dist.discrete.csv.twocol.xcolumn
# EventDVR.m_DVRprobDist.dist.discrete.csv.twocol.ycolumn
# EventDVR.m_DVRprobDist.dist.discrete.csv.twocol.floor
#
# The following depends on EventDVR.m_DVRprobDist.dist.type = discrete.inline
# EventDVR.m_DVRprobDist.dist.discrete.inline.xvalues
# EventDVR.m_DVRprobDist.dist.discrete.inline.yvalues
# EventDVR.m_DVRprobDist.dist.discrete.inline.floor
#
# The following depends on EventDVR.m_DVRprobDist.dist.type = exponential
# EventDVR.m_DVRprobDist.dist.exponential.lambda
#
# The following depends on EventDVR.m_DVRprobDist.dist.type = fixed
# EventDVR.m_DVRprobDist.dist.fixed.value
#
# The following depends on EventDVR.m_DVRprobDist.dist.type = gamma
# EventDVR.m_DVRprobDist.dist.gamma.a
# EventDVR.m_DVRprobDist.dist.gamma.b
#
# The following depends on EventDVR.m_DVRprobDist.dist.type = lognormal
# EventDVR.m_DVRprobDist.dist.lognormal.zeta
# EventDVR.m_DVRprobDist.dist.lognormal.sigma
#
# The following depends on EventDVR.m_DVRprobDist.dist.type = normal
# EventDVR.m_DVRprobDist.dist.normal.mu
# EventDVR.m_DVRprobDist.dist.normal.sigma
# EventDVR.m_DVRprobDist.dist.normal.min
# EventDVR.m_DVRprobDist.dist.normal.max
#

# TODO
population.coarsemap.subdivx                                 = 20
population.coarsemap.subdivy                                 = 20

# agywage represents the age at which we set the AGYW property to False
# and to enable or disable the AGYW event.
EventAGYW.agywage                                            = 25
# Valid values are: ['true', 'false']
EventAGYW.enabled                                            = false

# Indicates the time interval before death that the AIDS stages occur
# The defaults are 15 and 6 months before death
aidsstage.start                                              = 1.25
aidsstage.final                                              = 0.5

# When someone is born, a random number is chosen from [0,1],
# and if smaller than this boygirlratio, the new child is male. Otherwise, a 
# woman is added to the population.
# 
# Default is 1.0/2.01
birth.boygirlratio                                           = 0.497512437810945

# This parameter is used to specify the pregnancy duration. The default
# is the fixed value of 268/365
# Valid values are: ['fixed', 'uniform', 'beta', 'gamma', 'lognormal', 'normal', 'exponential', 'discrete.inline', 'discrete.csv.onecol', 'discrete.csv.twocol']
birth.pregnancyduration.dist.type                            = fixed

# The following depends on birth.pregnancyduration.dist.type = fixed
# Each time a value is picked from this 'distribution', the specified fixed 
# value is returned.
birth.pregnancyduration.dist.fixed.value                     = 0.734246575342466

# This event allows you to check at regular intervals if the program run time
# exceeded a preset limit, or if the population size is growing too large.
checkstop.interval                                           = -1
checkstop.max.runtime                                        = inf
checkstop.max.popsize                                        = inf

# Duration of the acute stage. 3 months = 3/12 = 0.25
chronicstage.acutestagetime                                  = 0.25

# Parameters for the conception event. Hazard is 
#     h = exp(alpha_base + alpha_ageman * AgeMan(t) + alpha_agewoman * AgeWoman(t) 
#             + alpha_wsf * WSF + beta*(t-t_ref) )
# 
# Here, WSF is a number that's generated at random from the specified distribution
# when a conception event is scheduled.
conception.alpha_base                                        = -2.96420552
conception.alpha_ageman                                      = 0
conception.alpha_agewoman                                    = 0
conception.alpha_wsf                                         = 0
conception.beta                                              = 0
conception.t_max                                             = 200
# Valid values are: ['fixed', 'uniform', 'beta', 'gamma', 'lognormal', 'normal', 'exponential', 'discrete.inline', 'discrete.csv.onecol', 'discrete.csv.twocol']
conception.wsf.dist.type                                     = fixed

# The following depends on conception.wsf.dist.type = fixed
# Each time a value is picked from this 'distribution', the specified fixed 
# value is returned.
conception.wsf.dist.fixed.value                              = 0

# This parameter is used to set the distribution of subject willing to accept Condom treatment
# and to enable or disable the Condom event.
# Valid values are: ['true', 'false']
EventCondom.enabled                                          = false
EventCondom.AGYWthreshold                                    = 0
EventCondom.threshold                                        = 9999
# Valid values are: ['fixed', 'uniform', 'beta', 'gamma', 'lognormal', 'normal', 'exponential', 'discrete.inline', 'discrete.csv.onecol', 'discrete.csv.twocol']
EventCondom.m_condomprobDist.dist.type                       = uniform
# Valid values are: ['fixed', 'uniform', 'beta', 'gamma', 'lognormal', 'normal', 'exponential', 'discrete.inline', 'discrete.csv.onecol', 'discrete.csv.twocol']
EventCondom.m_condomscheduleDist.dist.type                   = uniform

# The following depends on EventCondom.m_condomprobDist.dist.type = uniform
# Parameters for a uniform distribution
EventCondom.m_condomprobDist.dist.uniform.min                = 0
EventCondom.m_condomprobDist.dist.uniform.max                = 1

# The following depends on EventCondom.m_condomscheduleDist.dist.type = uniform
# Parameters for a uniform distribution
EventCondom.m_condomscheduleDist.dist.uniform.min            = 0
EventCondom.m_condomscheduleDist.dist.uniform.max            = 1

# This parameter is used to set the distribution of subject willing to accept VMMC treatment
# and to enable or disable the VMMC event.
# Valid values are: ['true', 'false']
EventDVRDROP.enabled                                         = false
EventDVRDROP.threshold                                       = 1
EventDVRDROP.schedulemin                                     = 1
EventDVRDROP.schedulemax                                     = 5
# Valid values are: ['fixed', 'uniform', 'beta', 'gamma', 'lognormal', 'normal', 'exponential', 'discrete.inline', 'discrete.csv.onecol', 'discrete.csv.twocol']
EventDVRDROP.m_DVRDROPprobDist.dist.type                     = uniform

# The following depends on EventDVRDROP.m_DVRDROPprobDist.dist.type = uniform
# Parameters for a uniform distribution
EventDVRDROP.m_DVRDROPprobDist.dist.uniform.min              = 0
EventDVRDROP.m_DVRDROPprobDist.dist.uniform.max              = 1

# Age at which a person becomes sexually active and can form
# relationships
debut.debutage                                               = 15

# When a person gets infected or drops out of treatment, a diagnosis event is 
# scheduled of which the fire time is determined by the following hazard:
# 
#  h = exp(baseline + agefactor*A(t) + genderfactor*G 
#          + diagpartnersfactor*ND + isdiagnosedfactor*D
#          + beta*t + HSV2factor*HSV2 + eagernessfactor*E + pregnancyfactor*P + AGYWfactor*Y)
# 
# Here, A(t) is the age of the person, G is the gender (0 for a man, 1 for a
# woman), ND is the number of diagnosed partners and D is a flag (0 or 1)
# indicating if the person has been on treatment before (to have different
# behaviour for first diagnosis and re-testing after dropout).
diagnosis.baseline                                           = -99999
diagnosis.agefactor                                          = 0
diagnosis.genderfactor                                       = 0
diagnosis.diagpartnersfactor                                 = 0
diagnosis.isdiagnosedfactor                                  = 0
diagnosis.beta                                               = 0
diagnosis.HSV2factor                                         = 0
diagnosis.eagernessfactor                                    = 0.02182677
diagnosis.pregnancyfactor                                    = 0
diagnosis.AGYWfactor                                         = 0
diagnosis.t_max                                              = 200

# These are the parameters for the hazard in the dissolution event.
# see http://research.edm.uhasselt.be/jori/simpact/
# for more information.
dissolution.alpha_0                                          = -2.17660947
dissolution.alpha_1                                          = 0
dissolution.alpha_2                                          = 0
dissolution.alpha_3                                          = 0
dissolution.alpha_4                                          = -0.05
dissolution.alpha_5                                          = 0
dissolution.Dp                                               = 0
dissolution.beta                                             = 0
dissolution.t_max                                            = 200

# These are the parameters for the hazard in the dissolution event.
# see http://research.edm.uhasselt.be/jori/simpact/
# for more information.
dissolutionmsm.alpha_0                                       = 0.1
dissolutionmsm.alpha_12                                      = 0
dissolutionmsm.alpha_3                                       = 0
dissolutionmsm.alpha_4                                       = 0
dissolutionmsm.alpha_5                                       = 0
dissolutionmsm.beta                                          = 0
dissolutionmsm.t_max                                         = 200

# Distribution to schedule dropout events.
# Valid values are: ['fixed', 'uniform', 'beta', 'gamma', 'lognormal', 'normal', 'exponential', 'discrete.inline', 'discrete.csv.onecol', 'discrete.csv.twocol']
dropout.interval.dist.type                                   = fixed

# The following depends on dropout.interval.dist.type = fixed
# Each time a value is picked from this 'distribution', the specified fixed 
# value is returned.
dropout.interval.dist.fixed.value                            = 500

# Valid values are: ['simple', 'agegap', 'agegapry']
formationmsm.hazard.type                                     = simple

# The following depends on formationmsm.hazard.type = simple
# These are the parameters for the hazard in the simple formation event.
# see http://research.edm.uhasselt.be/jori/simpact/
# for more information.
formationmsm.hazard.simple.alpha_0                           = 2
formationmsm.hazard.simple.alpha_12                          = -0.4
formationmsm.hazard.simple.alpha_3                           = 0
formationmsm.hazard.simple.alpha_4                           = 0
formationmsm.hazard.simple.alpha_5                           = -0.2
formationmsm.hazard.simple.alpha_6                           = 0
formationmsm.hazard.simple.alpha_7                           = 0
formationmsm.hazard.simple.alpha_dist                        = 0
formationmsm.hazard.simple.beta                              = 0
formationmsm.hazard.simple.t_max                             = 200

# Valid values are: ['simple', 'agegap', 'agegapry']
formation.hazard.type                                        = agegapry

# The following depends on formation.hazard.type = agegapry
# These are the parameters for the hazard in the 'agegapry' formation event.
# see http://research.edm.uhasselt.be/jori/simpact/
# for more information.
formation.hazard.agegapry.baseline                           = 4.52543549
formation.hazard.agegapry.numrel_man                         = -0.47103921
formation.hazard.agegapry.numrel_scale_man                   = 0
formation.hazard.agegapry.numrel_woman                       = -0.39755177
formation.hazard.agegapry.numrel_scale_woman                 = 0
formation.hazard.agegapry.numrel_diff                        = -0.1
formation.hazard.agegapry.meanage                            = -0.03
formation.hazard.agegapry.eagerness_sum                      = 0.1
formation.hazard.agegapry.eagerness_diff                     = -0.048
formation.hazard.agegapry.gap_factor_man_const               = 0
formation.hazard.agegapry.gap_factor_man_exp                 = -1.12659179
formation.hazard.agegapry.gap_factor_man_age                 = -0.02
formation.hazard.agegapry.gap_agescale_man                   = 0.26149244
formation.hazard.agegapry.gap_factor_woman_const             = 0
formation.hazard.agegapry.gap_factor_woman_exp               = -1.12659179
formation.hazard.agegapry.gap_factor_woman_age               = -0.02
formation.hazard.agegapry.gap_agescale_woman                 = 0.30758427
formation.hazard.agegapry.distance                           = 0
formation.hazard.agegapry.beta                               = 0
formation.hazard.agegapry.t_max                              = 200
formation.hazard.agegapry.maxageref.diff                     = 1

# Controls when the initial HIV seeders are introduced, and who those seeders
# are. First, the possible seeders are chosen from the population, based on the
# specified mininum and maximum ages, and on the specified gender.
# 
# The specified time says when the seeding event should take place. Note that
# if the time is negative, no seeders will be introduced since the event will 
# be ignored (simulation time starts at t = 0).
hivseed.time                                                 = 8.5
# Valid values are: ['fraction', 'amount']
hivseed.type                                                 = amount
hivseed.age.min                                              = 20
hivseed.age.max                                              = 50
# Valid values are: ['any', 'male', 'female']
hivseed.gender                                               = any

# The following depends on hivseed.type = amount
# From the people who possibly can be seeded with HIV, the specified amount
# will be marked as infected. If the 'hivseed.stop.short' parameter is set to
# 'yes' and there were not enough people that could be infected, the program
# will abort.
hivseed.amount                                               = 15
# Valid values are: ['yes', 'no']
hivseed.stop.short                                           = yes

# The hazard of transmission is h = exp(a + b * V^(-c) + d1*Pi + d2*Pj + e1*Hi + e2*Hj + g1*b0_j + g2*b1_j + v1*Vi + k*Ki)
# in case the uninfected partner is a man, or
# h = exp(a + b * V^(-c) + d1*Pi + d2*Pj +e1*Hi + e2*Hj + f1*exp(f2(A(try)-Ad))+ g1*b0_j + g2*b1_j)
# in case the uninfected partner is a woman. The value of V is the viral
# load, which is not necessarily the set-point viral load but will differ
# depending on the AIDS stage.
hivtransmission.param.a                                      = -2.0715203
hivtransmission.param.b                                      = -90
hivtransmission.param.c                                      = 0.5
hivtransmission.param.d1                                     = 0
hivtransmission.param.d2                                     = 0
hivtransmission.param.e1                                     = 0
hivtransmission.param.e2                                     = 0
hivtransmission.param.f1                                     = 2.33275708
hivtransmission.param.f2                                     = -0.13862944
hivtransmission.param.g1                                     = 0
hivtransmission.param.g2                                     = 0
hivtransmission.param.v1                                     = -0.916
hivtransmission.param.k                                      = -1.203
hivtransmission.param.p                                      = -1.6094
hivtransmission.param.p1                                     = -0.6931
hivtransmission.param.p2                                     = -2.9957
hivtransmission.threshold                                    = 9999
# Valid values are: ['fixed', 'uniform', 'beta', 'gamma', 'lognormal', 'normal', 'exponential', 'discrete.inline', 'discrete.csv.onecol', 'discrete.csv.twocol']
hivtransmission.m_condomformationdist.dist.type              = discrete.csv.twocol
hivtransmission.maxageref.diff                               = 1

# The following depends on hivtransmission.m_condomformationdist.dist.type = discrete.csv.twocol
# TODO
hivtransmission.m_condomformationdist.dist.discrete.csv.twocol.file = /home/jupyter/who-aids-prop/build/python/relationship_condom_use_0.csv
hivtransmission.m_condomformationdist.dist.discrete.csv.twocol.xcolumn = 1
hivtransmission.m_condomformationdist.dist.discrete.csv.twocol.ycolumn = 2
hivtransmission.m_condomformationdist.dist.discrete.csv.twocol.floor = yes

# Controls when the initial HSV2 seeders are introduced, and who those seeders
# are. First, the possible seeders are chosen from the population, based on the
# specified mininum and maximum ages, and on the specified gender.
# 
# The specified time says when the seeding event should take place. Note that
# if the time is negative, no seeders will be introduced since the event will 
# be ignored (simulation time starts at t = 0).
hsv2seed.time                                                = -1
# Valid values are: ['fraction', 'amount']
hsv2seed.type                                                = fraction
hsv2seed.age.min                                             = 0
hsv2seed.age.max                                             = 1000
# Valid values are: ['any', 'male', 'female']
hsv2seed.gender                                              = any

# The following depends on hsv2seed.type = fraction
# From the people who possibly can be seeded with HSV2, the specified fraction
# will be marked as infected.
hsv2seed.fraction                                            = 0.2

# These configuration parameters allow you to set the 'b', 'c' and 'd' values in the hazard
#  h = exp(a_i + b*(t-t_infected)+ c*M_i + d*H_i + e1*b0_j + e2*b2_j + v3 + v4)
# The value of 'a_i' depends on the individual, and can be specified as a 
# distribution in the person parameters 
# The value of 'b0_j' depends on the individual, and can be specified as a 
# distribution in the person parameters 
# The value of 'b2_j' depends on the individual, and can be specified as a 
# distribution in the person parameters.
hsv2transmission.hazard.b                                    = 0
hsv2transmission.hazard.c                                    = 0
hsv2transmission.hazard.d                                    = 0
hsv2transmission.hazard.e1                                   = 0
hsv2transmission.hazard.e2                                   = 0
hsv2transmission.hazard.v2                                   = -0.916
hsv2transmission.hazard.k2                                   = -1.6094
hsv2transmission.hazard.t_max                                = 200

# If you enable the intervention event, you need to specify a number of times
# at which this event should fire. On these times, some new configuration lines
# will be read, overriding the initial parameters read from config file.
# Valid values are: ['yes', 'no']
intervention.enabled                                         = yes

# The following depends on intervention.enabled = yes
# In 'intervention.times' you need to specify the times at which the 
# intervention event should fire. All times must be positive and the list
# of times must be increasing.
# 
# The 'intervention.baseconfigname' is the filename template that should be
# used to read the config settings from for the intervention events. For each
# intervention time, the '%' character will either be replaced by the 
# corresponding string from 'intervention.fileids', or by the time specified 
# in 'intervention.times' if you leave 'intervention.fileids' empty.
# 
# For example:
#   intervention.baseconfigname = intconfig_%.txt
#   intervention.times = 1,2,3
#   intervention.fileids = A,B,C
# will read intervention settings from 'intconfig_A.txt', 'intconfig_B.txt' and
# 'intconfig_C.txt'.
# 
# If you leave the file IDs empty,
#   intervention.fileids =
# then the files used would be 'intconfig_1.txt', 'intconfig_2.txt' and
# 'intconfig_3.txt'.
intervention.baseconfigname                                  = model_1_seed_1interventionconfig_%.txt
intervention.times                                           = 12.0,12.5,18.0,20.0,22.0,23.0,25.0,26.0,26.1,30.0,33.5,36.75,37.11,38.0,44.1293,47.1293
intervention.fileids                                         = 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16

# When a person is diagnosed (or 're-diagnosed' after a dropout), monitoring
# events will be scheduled using an interval that depends on the CD4 count.
# When such an event fires, and the person's CD4 count is below the specified
# CD4 threshold, the person may start ART treatment, if he/she is willing
# to do so (see person settings). 
# 
# If the person is treated, the SPVL will be lowered in such a way that on a 
# logarithmic scale the new value equals the specified fraction of the original
# viral load.
monitoring.cd4.threshold                                     = 1
monitoring.fraction.log_viralload                            = 0.3
# Valid values are: ['fixed', 'uniform', 'beta', 'gamma', 'lognormal', 'normal', 'exponential', 'discrete.inline', 'discrete.csv.onecol', 'discrete.csv.twocol']
monitoring.m_artDist.dist.type                               = normal

# The following depends on monitoring.m_artDist.dist.type = normal
# Parameters for a clipped normal distribution
# prob(x) = 1.0/(s*sqrt(2.0*pi)) * exp(- (x-m)^2 / (2.0*s^2))
# possibly truncated to [min,max] (using rejection sampling)
monitoring.m_artDist.dist.normal.mu                          = 0.45
monitoring.m_artDist.dist.normal.sigma                       = 0.2
monitoring.m_artDist.dist.normal.min                         = 0.15
monitoring.m_artDist.dist.normal.max                         = 0.75

# These parameters specify the interval with which monitoring events will take
# place. This is determined by a piecewise linear function, which is a function
# of the person's CD4 count and which will return the interval (the unit is one
# year).
# 
# The 'monitoring.interval.piecewise.cd4s' specify the x-values of this 
# piecewise linear function (comma separated list), while 
# 'monitoring.interval.piecewise.times' specified the corresponding y-values. 
# For an x-value (CD4 count) that's smaller than the smallest value in the list,
# the value in 'monitoring.interval.piecewise.left' will be returned. For an
# x-value that's larger than the largest value in the list, the value in
# 'monitoring.interval.piecewise.right' will be returned.
monitoring.interval.piecewise.cd4s                           = 200,350
monitoring.interval.piecewise.times                          = 0.25,0.25
monitoring.interval.piecewise.left                           = 0.16666
monitoring.interval.piecewise.right                          = 0.5

# Parameters for the calculation of the survival time from the
# set-point viral load: t_surv = C/Vsp^(-k) + art_e
mortality.aids.survtime.C                                    = 65
mortality.aids.survtime.k                                    = -0.2
# Valid values are: ['fixed', 'uniform', 'beta', 'gamma', 'lognormal', 'normal', 'exponential', 'discrete.inline', 'discrete.csv.onecol', 'discrete.csv.twocol']
mortality.aids.survtime.art_e.dist.type                      = uniform

# The following depends on mortality.aids.survtime.art_e.dist.type = uniform
# Parameters for a uniform distribution
mortality.aids.survtime.art_e.dist.uniform.min               = 5
mortality.aids.survtime.art_e.dist.uniform.max               = 25

# Parameters for the weibull distribution from which a non-aids
# time of death is picked.
mortality.normal.weibull.shape                               = 5
mortality.normal.weibull.scale                               = 65
mortality.normal.weibull.genderdiff                          = 0

# During the simulation, at regular time intervals certain extra information
# can be logged with this event. Set the interval value to positive to enable,
# otherwise it will be disabled. If the starttime is negative, the first event,
# will take place after the first interval, otherwise at the specified time.
periodiclogging.interval                                     = 0.25
periodiclogging.starttime                                    = -1
periodiclogging.outfile.logperiodic                          = ${SIMPACT_OUTPUT_PREFIX}periodiclog.csv

# This parameter is used to set the distribution of subject willing to accept VMMC treatment
# and to enable or disable the VMMC event.
# Valid values are: ['true', 'false']
EventPrep.enabled                                            = false
EventPrep.AGYWthreshold                                      = 0
EventPrep.threshold                                          = 1
# Valid values are: ['fixed', 'uniform', 'beta', 'gamma', 'lognormal', 'normal', 'exponential', 'discrete.inline', 'discrete.csv.onecol', 'discrete.csv.twocol']
EventPrep.m_prepprobDist.dist.type                           = uniform

# Distribution to schedule dropout of prep intervention.
EventPrepDrop.threshold                                      = 1
# Valid values are: ['fixed', 'uniform', 'beta', 'gamma', 'lognormal', 'normal', 'exponential', 'discrete.inline', 'discrete.csv.onecol', 'discrete.csv.twocol']
EventPrepDrop.interval.dist.type                             = uniform

# The following depends on EventPrepDrop.interval.dist.type = uniform
# Parameters for a uniform distribution
EventPrepDrop.interval.dist.uniform.min                      = 0
EventPrepDrop.interval.dist.uniform.max                      = 1

# The following depends on EventPrep.m_prepprobDist.dist.type = uniform
# Parameters for a uniform distribution
EventPrep.m_prepprobDist.dist.uniform.min                    = 0
EventPrep.m_prepprobDist.dist.uniform.max                    = 1

# This parameter is used to specify the VMMC scheduling duration. The default is fixed.
# Valid values are: ['fixed', 'uniform', 'beta', 'gamma', 'lognormal', 'normal', 'exponential', 'discrete.inline', 'discrete.csv.onecol', 'discrete.csv.twocol']
EventPrep.m_prepscheduleDist.dist.type                       = fixed

# The following depends on EventPrep.m_prepscheduleDist.dist.type = fixed
# Each time a value is picked from this 'distribution', the specified fixed 
# value is returned.
EventPrep.m_prepscheduleDist.dist.fixed.value                = 0.246575

# TODO
relocation.enabled                                           = no

# Some events (e.g. a relationship formation event) use the last known 
# population size to normalize a hazard. By default, the population size 
# at the start of the simulation is used for this, which is fine if the 
# population size remains roughly constant. For rapidly growing or 
# shrinking populations, this is not correct however.
# 
# By setting this interval to a positive number, the last known population
# size will be recalculated periodically. Note that this will also cause all
# event times in the simulation to be recalculated, so settings this to a low
# value can certainly slow things down.
syncpopstats.interval                                        = -1

# In the hazards of some events, instead of using the actual simulation time
# a reference time is used. This typically makes the integrals involved much
# easier to calculate. This interval specifies how often this reference time
# is saved for use in these hazards. Note that all other event times are
# recalculated after firing this event, so very frequent updates of this
# reference time can slow down the simulation considerably.
syncrefyear.interval                                         = 1

# This parameter is used to set the distribution of subject willing to accept VMMC treatment
# and to enable or disable the VMMC event.
# Valid values are: ['true', 'false']
EventVMMC.enabled                                            = false
EventVMMC.threshold                                          = 0.3
# Valid values are: ['fixed', 'uniform', 'beta', 'gamma', 'lognormal', 'normal', 'exponential', 'discrete.inline', 'discrete.csv.onecol', 'discrete.csv.twocol']
EventVMMC.m_vmmcprobDist.dist.type                           = uniform

# The following depends on EventVMMC.m_vmmcprobDist.dist.type = uniform
# Parameters for a uniform distribution
EventVMMC.m_vmmcprobDist.dist.uniform.min                    = 0
EventVMMC.m_vmmcprobDist.dist.uniform.max                    = 1

# This parameter is used to specify the VMMC scheduling duration. The default is fixed.
# Valid values are: ['fixed', 'uniform', 'beta', 'gamma', 'lognormal', 'normal', 'exponential', 'discrete.inline', 'discrete.csv.onecol', 'discrete.csv.twocol']
EventVMMC.m_vmmcscheduleDist.dist.type                       = discrete.csv.twocol

# The following depends on EventVMMC.m_vmmcscheduleDist.dist.type = discrete.csv.twocol
# TODO
EventVMMC.m_vmmcscheduleDist.dist.discrete.csv.twocol.file   = /home/jupyter/who-aids-prop/build/python/vmmc_schedule_twocol_0_0.csv
EventVMMC.m_vmmcscheduleDist.dist.discrete.csv.twocol.xcolumn = 1
EventVMMC.m_vmmcscheduleDist.dist.discrete.csv.twocol.ycolumn = 2
EventVMMC.m_vmmcscheduleDist.dist.discrete.csv.twocol.floor  = no

logsystem.outfile.logevents                                  = ${SIMPACT_OUTPUT_PREFIX}eventlog.csv
logsystem.outfile.logpersons                                 = ${SIMPACT_OUTPUT_PREFIX}personlog.csv
logsystem.outfile.logrelations                               = ${SIMPACT_OUTPUT_PREFIX}relationlog.csv
logsystem.outfile.logtreatments                              = ${SIMPACT_OUTPUT_PREFIX}treatmentlog.csv
logsystem.outfile.logsettings                                = ${SIMPACT_OUTPUT_PREFIX}settingslog.csv
logsystem.outfile.loglocation                                = ${SIMPACT_OUTPUT_PREFIX}locationlog.csv
logsystem.outfile.logviralloadhiv                            = ${SIMPACT_OUTPUT_PREFIX}hivviralloadlog.csv

# This parameter specifies a distribution from which a number will be chosen
# for each person, and which serves as the threshold to start ART (if eligible).
# When eligible for treatment, a random number will be chosen uniformly from
# [0,1], and treatment will only be started if this number is smaller than the
# threshold. By default, everyone will just have a 50/50 chance of starting
# treatment when possible. 
# 
# If this distribution returns a low value (close to zero), it means that 
# there's little chance of accepting treatment; if the value is higher (close to
# one), treatment will almost always be accepted.
# Valid values are: ['fixed', 'uniform', 'beta', 'gamma', 'lognormal', 'normal', 'exponential', 'discrete.inline', 'discrete.csv.onecol', 'discrete.csv.twocol']
person.art.accept.threshold.dist.type                        = fixed

# The following depends on person.art.accept.threshold.dist.type = fixed
# Each time a value is picked from this 'distribution', the specified fixed 
# value is returned.
person.art.accept.threshold.dist.fixed.value                 = 0.3

# Valid values are: ['fixed', 'uniform', 'beta', 'gamma', 'lognormal', 'normal', 'exponential', 'discrete.inline', 'discrete.csv.onecol', 'discrete.csv.twocol']
person.agegap.man.msm.dist.type                              = fixed

# The following depends on person.agegap.man.msm.dist.type = fixed
# Each time a value is picked from this 'distribution', the specified fixed 
# value is returned.
person.agegap.man.msm.dist.fixed.value                       = 0

# Valid values are: ['fixed', 'uniform', 'beta', 'gamma', 'lognormal', 'normal', 'exponential', 'discrete.inline', 'discrete.csv.onecol', 'discrete.csv.twocol']
person.agegap.man.dist.type                                  = normal

# The following depends on person.agegap.man.dist.type = normal
# Parameters for a clipped normal distribution
# prob(x) = 1.0/(s*sqrt(2.0*pi)) * exp(- (x-m)^2 / (2.0*s^2))
# possibly truncated to [min,max] (using rejection sampling)
person.agegap.man.dist.normal.mu                             = -1.4636124
person.agegap.man.dist.normal.sigma                          = 4.28106687
person.agegap.man.dist.normal.min                            = -inf
person.agegap.man.dist.normal.max                            = inf

# Valid values are: ['fixed', 'uniform', 'beta', 'gamma', 'lognormal', 'normal', 'exponential', 'discrete.inline', 'discrete.csv.onecol', 'discrete.csv.twocol']
person.agegap.woman.wsw.dist.type                            = fixed

# The following depends on person.agegap.woman.wsw.dist.type = fixed
# Each time a value is picked from this 'distribution', the specified fixed 
# value is returned.
person.agegap.woman.wsw.dist.fixed.value                     = 0

# Valid values are: ['fixed', 'uniform', 'beta', 'gamma', 'lognormal', 'normal', 'exponential', 'discrete.inline', 'discrete.csv.onecol', 'discrete.csv.twocol']
person.agegap.woman.dist.type                                = normal

# The following depends on person.agegap.woman.dist.type = normal
# Parameters for a clipped normal distribution
# prob(x) = 1.0/(s*sqrt(2.0*pi)) * exp(- (x-m)^2 / (2.0*s^2))
# possibly truncated to [min,max] (using rejection sampling)
person.agegap.woman.dist.normal.mu                           = -1.36506176
person.agegap.woman.dist.normal.sigma                        = 3.82097928
person.agegap.woman.dist.normal.min                          = -inf
person.agegap.woman.dist.normal.max                          = inf

# These distributions control the initial CD4 count when first getting infected
# and the final CD4 count at the time the person dies from AIDS.
# Valid values are: ['fixed', 'uniform', 'beta', 'gamma', 'lognormal', 'normal', 'exponential', 'discrete.inline', 'discrete.csv.onecol', 'discrete.csv.twocol']
person.cd4.start.dist.type                                   = lognormal
# Valid values are: ['fixed', 'uniform', 'beta', 'gamma', 'lognormal', 'normal', 'exponential', 'discrete.inline', 'discrete.csv.onecol', 'discrete.csv.twocol']
person.cd4.end.dist.type                                     = lognormal

# The following depends on person.cd4.start.dist.type = lognormal
# Parameters for a log-normal distribution
# prob(x) = 1.0/(x*s*sqrt(2.0*pi)) * exp(- (ln(x)-z)^2 / (2.0*s^2))
person.cd4.start.dist.lognormal.zeta                         = 6.65429941675971
person.cd4.start.dist.lognormal.sigma                        = 0.24622067706924

# The following depends on person.cd4.end.dist.type = lognormal
# Parameters for a log-normal distribution
# prob(x) = 1.0/(x*s*sqrt(2.0*pi)) * exp(- (ln(x)-z)^2 / (2.0*s^2))
person.cd4.end.dist.lognormal.zeta                           = 2.98952101355471
person.cd4.end.dist.lognormal.sigma                          = 0.111456359166075

# The following depends on person.eagerness.man.type = independent
# TODO
# Valid values are: ['fixed', 'uniform', 'beta', 'gamma', 'lognormal', 'normal', 'exponential', 'discrete.inline', 'discrete.csv.onecol', 'discrete.csv.twocol']
person.eagerness.man.dist.type                               = gamma

# The following depends on person.eagerness.man.type = independent
# TODO
# Valid values are: ['fixed', 'uniform', 'beta', 'gamma', 'lognormal', 'normal', 'exponential', 'discrete.inline', 'discrete.csv.onecol', 'discrete.csv.twocol']
person.eagerness.man.msm.dist.type                           = fixed

# The following depends on person.eagerness.man.msm.dist.type = fixed
# Each time a value is picked from this 'distribution', the specified fixed 
# value is returned.
person.eagerness.man.msm.dist.fixed.value                    = 0

# The following depends on person.eagerness.man.dist.type = gamma
# Parameters for a gamma distribution
# prob(x) = (x^(a-1.0))*exp(-x/b)/((b^a)*gamma(a))
person.eagerness.man.dist.gamma.a                            = 0.73574298
person.eagerness.man.dist.gamma.b                            = 49.16761935

# TODO
# Valid values are: ['independent', 'joint']
person.eagerness.man.type                                    = independent

# TODO
# Valid values are: ['independent', 'joint']
person.eagerness.woman.type                                  = independent

# The following depends on person.eagerness.woman.type = independent
# TODO
# Valid values are: ['fixed', 'uniform', 'beta', 'gamma', 'lognormal', 'normal', 'exponential', 'discrete.inline', 'discrete.csv.onecol', 'discrete.csv.twocol']
person.eagerness.woman.dist.type                             = gamma

# The following depends on person.eagerness.woman.type = independent
# TODO
# Valid values are: ['fixed', 'uniform', 'beta', 'gamma', 'lognormal', 'normal', 'exponential', 'discrete.inline', 'discrete.csv.onecol', 'discrete.csv.twocol']
person.eagerness.woman.wsw.dist.type                         = fixed

# The following depends on person.eagerness.woman.wsw.dist.type = fixed
# Each time a value is picked from this 'distribution', the specified fixed 
# value is returned.
person.eagerness.woman.wsw.dist.fixed.value                  = 0

# The following depends on person.eagerness.woman.dist.type = gamma
# Parameters for a gamma distribution
# prob(x) = (x^(a-1.0))*exp(-x/b)/((b^a)*gamma(a))
person.eagerness.woman.dist.gamma.a                          = 0.27489344
person.eagerness.woman.dist.gamma.b                          = 47.29128728

# The distribution specified by 'person.geo.dist2d' is used to assign (x,y)
# location coordinates to a person.
# Valid values are: ['fixed', 'uniform', 'binormal', 'binormalsymm', 'discrete']
person.geo.dist2d.type                                       = fixed

# The following depends on person.geo.dist2d.type = fixed
# Each time a value from this 'distribution' is picked, the specified x- and
# y- values will be returned.
person.geo.dist2d.fixed.xvalue                               = 0
person.geo.dist2d.fixed.yvalue                               = 0

# The 'b0' parameter in the HIV transmission hazard is chosen from this
# distribution, allowing transmission to
# depend more on susceptibility for both infections
# The 'b1' parameter in the HIV transmission hazard is chosen from this
# distribution, allowing transmission to
# depend more on susceptibility for HIV only.
# Valid values are: ['fixed', 'uniform', 'beta', 'gamma', 'lognormal', 'normal', 'exponential', 'discrete.inline', 'discrete.csv.onecol', 'discrete.csv.twocol']
person.hiv.b0.dist.type                                      = fixed
# Valid values are: ['fixed', 'uniform', 'beta', 'gamma', 'lognormal', 'normal', 'exponential', 'discrete.inline', 'discrete.csv.onecol', 'discrete.csv.twocol']
person.hiv.b1.dist.type                                      = fixed

# The following depends on person.hiv.b0.dist.type = fixed
# Each time a value is picked from this 'distribution', the specified fixed 
# value is returned.
person.hiv.b0.dist.fixed.value                               = 0

# The following depends on person.hiv.b1.dist.type = fixed
# Each time a value is picked from this 'distribution', the specified fixed 
# value is returned.
person.hiv.b1.dist.fixed.value                               = 0

# The 'a' parameter in the HSV2 transmission hazard is chosen from this
# distribution, allowing transmission to depend more on the individual
# The 'b2' parameter in the HSV2 transmission hazard is chosen from this
# distribution, allowing transmission to
# depend more on susceptibility for HSV2 only.
# Valid values are: ['fixed', 'uniform', 'beta', 'gamma', 'lognormal', 'normal', 'exponential', 'discrete.inline', 'discrete.csv.onecol', 'discrete.csv.twocol']
person.hsv2.a.dist.type                                      = fixed
# Valid values are: ['fixed', 'uniform', 'beta', 'gamma', 'lognormal', 'normal', 'exponential', 'discrete.inline', 'discrete.csv.onecol', 'discrete.csv.twocol']
person.hsv2.b2.dist.type                                     = fixed

# The following depends on person.hsv2.a.dist.type = fixed
# Each time a value is picked from this 'distribution', the specified fixed 
# value is returned.
person.hsv2.a.dist.fixed.value                               = 0

# The following depends on person.hsv2.b2.dist.type = fixed
# Each time a value is picked from this 'distribution', the specified fixed 
# value is returned.
person.hsv2.b2.dist.fixed.value                              = 0

# By configuring this, you can add an offset to the survival time that differs
# per person, so the relationship between survival time and viral load will
# show some scatter. The offset is added to the logarithm of the survival time.
# Valid values are: ['fixed', 'uniform', 'beta', 'gamma', 'lognormal', 'normal', 'exponential', 'discrete.inline', 'discrete.csv.onecol', 'discrete.csv.twocol']
person.survtime.logoffset.dist.type                          = normal

# The following depends on person.survtime.logoffset.dist.type = normal
# Parameters for a clipped normal distribution
# prob(x) = 1.0/(s*sqrt(2.0*pi)) * exp(- (x-m)^2 / (2.0*s^2))
# possibly truncated to [min,max] (using rejection sampling)
person.survtime.logoffset.dist.normal.mu                     = 0
person.survtime.logoffset.dist.normal.sigma                  = 0.2
person.survtime.logoffset.dist.normal.min                    = -inf
person.survtime.logoffset.dist.normal.max                    = inf

# The viral load during the other stages is based on the set point viral load:
#    V = [ max(ln(x)/b + Vsp^(-c), maxvalue^(-c)) ]^(-1/c)
# The b and c parameters are specified in the parameters from the transmission
# event.
person.vsp.toacute.x                                         = 5
person.vsp.toaids.x                                          = 7
person.vsp.tofinalaids.x                                     = 12
person.vsp.maxvalue                                          = 1000000000

# The type of model to use for the Vsp value of the seeders and for inheriting
# Vsp values.
# Valid values are: ['logweibullwithnoise', 'logdist2d']
person.vsp.model.type                                        = logdist2d

# The following depends on person.vsp.model.type = logdist2d
# Both the initial 'seed' value and the inherited Vsp value are
# chosen so that the log value is based on the specified 2D distribution.
# 
# Additionally, you can also specify that an alternative distribution must
# be used to pick the Vsp values of the seeders.
# Valid values are: ['fixed', 'uniform', 'binormal', 'binormalsymm', 'discrete']
person.vsp.model.logdist2d.dist2d.type                       = binormalsymm
# Valid values are: ['yes', 'no']
person.vsp.model.logdist2d.usealternativeseeddist            = no

# The following depends on person.vsp.model.logdist2d.dist2d.type = binormalsymm
# Parameters for a symmetric clipped binormal distribution, based on
# prob(x,y) = 1.0/(2.0*pi*sigma^2*sqrt(1.0-rho^2))
#           * exp[-(x^2 + y^2 - 2.0*rho*x*y)/(2.0*sigma^2*(1.0-rho^2))]
# Clipping to the specified region is done using rejection sampling
person.vsp.model.logdist2d.dist2d.binormalsymm.mean          = 4
person.vsp.model.logdist2d.dist2d.binormalsymm.sigma         = 1
person.vsp.model.logdist2d.dist2d.binormalsymm.rho           = 0.33
person.vsp.model.logdist2d.dist2d.binormalsymm.min           = 2
person.vsp.model.logdist2d.dist2d.binormalsymm.max           = 6

# By default, the 'maxevents' parameter is negative, causing it to be
# ignored. Set this to a positive value to make sure the simulation stops
# when this number of events has been exceeded.
population.nummen                                            = 1000
population.numwomen                                          = 1000
population.simtime                                           = 71
population.maxevents                                         = -1
population.agedistfile                                       = /home/jupyter/who-aids-prop/build/python/eswatini_1980.csv
population.msm                                               = no

# If set to 1, formation events will be scheduled for all man,woman
# pairs (who are both sexually active). This is the default behaviour.
# If set to a smaller number, only a fraction of the formation events 
# that would otherwise be scheduled are now used. This fraction is not 
# only used in the initial scheduling of formation events, but also 
# when a debut event fires, to limit the newly scheduled formation events.
population.eyecap.fraction                                   = 0.2

# This parameter is used to set the distribution of subject willing to accept CAB treatment
# and to enable or disable the CAB event.
# Valid values are: ['true', 'false']
EventCAB.enabled                                             = false
EventCAB.threshold                                           = 1
# Valid values are: ['fixed', 'uniform', 'beta', 'gamma', 'lognormal', 'normal', 'exponential', 'discrete.inline', 'discrete.csv.onecol', 'discrete.csv.twocol']
EventCAB.m_CABprobDist.dist.type                             = uniform

# This parameter is used to set the distribution of subject willing to accept CAB treatment
# and to enable or disable the CAB event.
# Valid values are: ['true', 'false']
EventCABDROP.enabled                                         = false
EventCABDROP.threshold                                       = 1
# Valid values are: ['fixed', 'uniform', 'beta', 'gamma', 'lognormal', 'normal', 'exponential', 'discrete.inline', 'discrete.csv.onecol', 'discrete.csv.twocol']
EventCABDROP.m_CABDROPprobDist.dist.type                     = uniform

# The following depends on EventCABDROP.m_CABDROPprobDist.dist.type = uniform
# Parameters for a uniform distribution
EventCABDROP.m_CABDROPprobDist.dist.uniform.min              = 0
EventCABDROP.m_CABDROPprobDist.dist.uniform.max              = 1

# The following depends on EventCAB.m_CABprobDist.dist.type = uniform
# Parameters for a uniform distribution
EventCAB.m_CABprobDist.dist.uniform.min                      = 0
EventCAB.m_CABprobDist.dist.uniform.max                      = 1

# This parameter is used to set the distribution of subject willing to accept VMMC treatment
# and to enable or disable the VMMC event.
# Valid values are: ['true', 'false']
EventDVR.enabled                                             = false
EventDVR.threshold                                           = 1
# Valid values are: ['fixed', 'uniform', 'beta', 'gamma', 'lognormal', 'normal', 'exponential', 'discrete.inline', 'discrete.csv.onecol', 'discrete.csv.twocol']
EventDVR.m_DVRprobDist.dist.type                             = uniform

# The following depends on EventDVR.m_DVRprobDist.dist.type = uniform
# Parameters for a uniform distribution
EventDVR.m_DVRprobDist.dist.uniform.min                      = 0
EventDVR.m_DVRprobDist.dist.uniform.max                      = 1

